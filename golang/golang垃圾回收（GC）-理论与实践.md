---
title: golang垃圾回收（GC） - 理论与实践
date: 2018-04-17 10:10:00
tags: Golang GC
---

[TOC]

## GC理论基础

### 考虑因素

下面列出了在设计垃圾回收算法时要考虑的一些因素：

- 程序吞吐量：回收算法会在多大程度上拖慢程序？有时候，这个是通过回收占用的CPU时间与其它CPU时间的百分比来描述的。
- GC吞吐量：在给定的CPU时间内，回收器可以回收多少垃圾？
- 堆内存开销：回收器最少需要多少额外的内存开销？如果回收器在回收垃圾时需要分配临时的内存，对于程序的内存使用是否会有严重影响？
- 停顿时间：回收器会造成多长时间的停顿？
- 停顿频率：回收器造成的停顿频率是怎样的？
- 停顿分布：停顿有时候很短暂，有时候很长？还是选择长一点但保持一致的停顿时间？
- 分配性能：新内存的分配是快、慢还是无法预测？
- 压缩：当堆内存里还有小块碎片化的内存可用时，回收器是否仍然抛出内存不足（OOM）的错误？如果不是，那么你是否发现程序越来越慢，并最终死掉，尽管仍然还有足够的内存可用？
- 并发：回收器是如何利用多核机器的？
- 伸缩：当堆内存变大时，回收器该如何工作？
- 调优：回收器的默认使用或在进行调优时，它的配置有多复杂？
- 预热时间：回收算法是否会根据已发生的行为进行自我调节？如果是，需要多长时间？
- 页释放：回收算法会把未使用的内存释放回给操作系统吗？如果会，会在什么时候发生？
- 可移植性：回收器是否能够在提供了较弱内存一致性保证的CPU架构上运行？
- 兼容性：回收器可以跟哪些编程语言和编译器一起工作？它可以跟那些并非为GC设计的编程语言一起工作吗，比如C++？它要求对编译器作出改动吗？如果是，那么是否意味着改变GC算法就需要对程序和依赖项进行重新编译？

以上给出的列表并没有包含了所有因素，可见，在设计垃圾回收器时需要考虑很多不同的因素，而且它们中有些还会影响到平台生态系统的设计。

### GC的折中

早期垃圾回收算法是为单核机器和小内存程序而设计的。那个时候，CPU和内存价格昂贵，而且用户没有太多的要求，即使有明显的停顿也没有关系。这个时期的GC设计更注重最小化回收器对CPU和堆内存的影响，也就是说，除非内存不足，否则GC什么事也不做。而当内存不足时，程序会被暂停，堆空间会被标记并清除（Mark-Sweep），部分内存会被尽快释放出来。

这种GC简称Mark-Sweep，计算机专业课程经常把会造成停顿（STW，Stop The World）的Mark-Sweep GC算法作为授课内容。

这种回收器很适合用在桌面应用里，因为桌面应用的堆内存一般不会很大。比如虚幻游戏引擎，它会在内存里存放数据文件，但不会被扫描到。

Mark-Sweep存在的最大问题是它的伸缩性很差。在增加CPU核数并加大堆空间之后，这种算法几乎无法工作。如果停顿时间对于你来说很敏感，则倾向使用一种能够在后台进行垃圾回收，并带来更短停顿时间的算法，尽管它会拖慢你的程序。

不过事情并不会像看上去的那么简单，在这种配置高端的服务器上可能运行着大批量的作业，因为它们是非交互性的，所以停顿时间对于你来说无关紧要，你只关心它们总的运行时间。在这种情况下，你最好使用一种可以最大化吞吐量的算法，尽量提高有效工作时间和回收时间之间的比率。

问题是，根本不存在十全十美的算法。没有任何一个语言运行时能够知道你的程序到底是一个批处理作业系统还是一个对延迟敏感的交互型应用。这也就是为什么会存在“GC调优”。

## 常见GC算法

### 1. 引用计数法

原理是在每个对象内部维护一个整数值，叫做这个对象的**引用计数**，当对象被引用时引用计数加一，当对象不被引用时引用计数减一。当引用计数为 0 时，自动销毁对象。

目前引用计数法主要用在 c++ 标准库的 std::shared_ptr 、微软的 COM 、Objective-C 和 PHP 中。

但是引用计数法有个缺陷就是不能解决循环引用的问题。循环引用是指对象 A 和对象 B 互相持有对方的引用。这样两个对象的引用计数都不是 0 ，因此永远不能被收集。

另外的缺陷是，每次对象的赋值都要将引用计数加一，增加了消耗。

### 2. Mark-Sweep法（标记清除法）

这个算法分为两步，标记和清除。

- 标记：从程序的根节点开始， **递归地**遍历所有对象，将能遍历到的对象打上标记。
- 清除：讲所有未标记的的对象当作垃圾销毁。

![Animation_of_the_Naive_Mark_and_Sweep_Garbage_Collector_Algorithm.gif-143.9kB](https://lengzzz.com/static/img/d86a2fc011c99baadcde3c12b046b2ef.gif) 
图片来自 [https://en.wikipedia.org/wiki/Tracing_garbage_collection](https://en.wikipedia.org/wiki/Tracing_garbage_collection) 

如图所示。

但是这个算法也有一个缺陷，就是人们常常说的 STW 问题（Stop The World）。因为算法在标记时必须暂停整个程序，否则其他线程的代码可能会改变对象状态，从而可能把不应该回收的对象当做垃圾收集掉。

当程序中的对象逐渐增多时，递归遍历整个对象树会消耗很多的时间，在大型程序中这个时间可能会是毫秒级别的。让所有的用户等待几百毫秒的 GC 时间这是不能容忍的。

golang 1.5以前使用的这个算法。

### 3. 三色标记法

三色标记法是传统 Mark-Sweep的一个改进，它是一个并发的 GC 算法。

原理如下，

1. 首先创建三个集合：**白、灰、黑**。
2. 将所有对象放入白色集合中。
3. 然后从根节点开始遍历所有对象（注意这里**并不递归遍历**），把遍历到的对象从白色集合放入灰色集合。
4. 之后遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合
5. 重复 4 直到灰色中无任何对象
6. 通过write-barrier检测对象有变化，重复以上操作
7. 收集所有白色对象（垃圾）

![Animation_of_tri-color_garbage_collection.gif-94kB](https://lengzzz.com/static/img/c9dbfac2f1b6bf5f73efe8dd6f551c36.gif) 
图片来自 [https://en.wikipedia.org/wiki/Tracing_garbage_collection](https://en.wikipedia.org/wiki/Tracing_garbage_collection) 

过程如上图所示。

这个算法可以实现 "on-the-fly"，也就是在程序执行的同时进行收集，并不需要暂停整个程序。

但是也会有一个缺陷，可能程序中的垃圾产生的速度会大于垃圾收集的速度，这样会导致程序中的垃圾越来越多无法被收集掉。

使用这种算法的是Go 1.5、Go 1.6。

### 4. 分代收集

分代收集也是传统 Mark-Sweep 的一个改进。这个算法是基于一个经验：绝大多数对象的生命周期都很短。所以按照对象的生命周期长短来进行分代。

一般 GC 都会分三代，在 java 中称之为新生代（Young Generation）、年老代（Tenured Generation）和永久代（Permanent Generation）；在 .NET 中称之为第 0 代、第 1 代和第2代。

原理如下：

- 新对象放入第 0 代
- 当内存用量超过一个较小的阈值时，触发 0 代收集
- 第 0 代幸存的对象（未被收集）放入第 1 代
- 只有当内存用量超过一个较高的阈值时，才会触发 1 代收集
- 2 代同理

因为 0 代中的对象十分少，所以每次收集时遍历都会非常快（比 1 代收集快几个数量级）。只有内存消耗过于大的时候才会触发较慢的 1 代和 2 代收集。

因此，分代收集是目前比较好的垃圾回收方式。使用的语言（平台）有 jvm、.NET 。

## Go GC

go 语言在 1.3 以前，使用的是比较简陋的传统 Mark-Sweep 算法。

1.3 版本进行了一下改进，把 Sweep 改为了并行操作。

1.5 版本进行了较大改进，使用了三色标记算法。go 1.5 在源码中的解释是“非分代的、非移动的、并发的、三色的标记清除垃圾收集器”

go 除了标准的三色收集以外，还有一个辅助回收功能，防止垃圾产生过快收集不过来的情况。这部分代码在 [`runtime.gcAssistAlloc`](https://golang.org/src/runtime/mgcmark.go#L316) 中。

但是 golang 并没有分代收集，所以对于巨量的小对象还是很苦手的，会导致整个mark过程十分长，在某些极端情况下，甚至会导致 GC 线程占据 50% 以上的 CPU。

因此，当程序由于高并发等原因造成大量小对象的gc问题时，最好可以使用 [`sync.Pool`](https://golang.org/pkg/sync/#Pool) 等对象池技术，避免大量小对象加大 GC 压力。

### GC主要流程

三色标记法，主要流程如下：

- 所有对象最开始都是白色。
- 从 root 开始找到所有可达对象，标记为灰色，放入待处理队列。
- 遍历待处理队列（灰色队列），将其引用对象也标记为灰色放入待处理队列，自身标记为黑色。
- 处理完待处理队列，执行清扫工作（清除白色对象）。

当完成所有的扫描和标记的工作后，剩余不是白色就是黑色，分别代表要回收和活跃对象，清理操作只需要把白色对象回收内存回收。

详细的过程如下图所示，具体可参考。
[![img](http://legendtkl.com/img/uploads/2017/gc.png)](http://legendtkl.com/img/uploads/2017/gc.png)

 说明：

1. 首先从 root 开始遍历，root包括全局指针和goroutine栈上的指针。

2. mark 有两个过程。

   1. 从 root 开始遍历，标记为灰色。遍历灰色队列。
   2. re-scan 全局指针和栈。因为 mark 和用户程序是并行的，所以在过程 1 的时候可能会有新的对象分配，这个时候就需要通过写屏障（write barrier）记录下来。re-scan 再完成检查一下。

3. Stop The World 有两次。

   1. 第一次是GC将要开始的时候，做一些准备工作，如启动写屏障(Write Barrier)和辅助GC(mutator assist)
   2. 第二次就是上面提到的 re-scan 过程。如果这个时候没有STW，那么mark将无休止。

   需要注意的是, 不是所有根对象的扫描都需要STW, 例如扫描栈上的对象只需要停止拥有该栈的G.

#### 增量回收

三色标记的目的，主要是用于做增量的垃圾回收。如果只有黑色和白色两种颜色，那么回收过程将不能中断，必须一次性完成，期间用户程序是不能运行的。

而使用三色标记，即使在标记过程中对象的引用关系发生了改变，例如分配内存并修改对象属性域的值，只要满足黑色对象不引用白色对象的约束条件，垃圾回收器就可以继续正常工作。于是每次并不需要将回收过程全部执行完，只是处理一部分后停下来，后续会慢慢再次触发的回收过程，实现**增量回收**。相当于是把垃圾回收过程打散，减少停顿时间。

#### 写屏障（write barrier）

>Wikipedia: A write barrier in a garbage collector is a fragment of code emitted by the compiler immediately before every store operation to ensure that (e.g.) generational invariants are maintained.

垃圾回收中的 write barrier 可以理解为编译器在写操作时特意插入的一段代码，对应的还有 read barrier。

为什么需要 write barrier，很简单，对于和用户程序并发运行的垃圾回收算法，用户程序会一直修改内存，所以需要记录下来。三色标记中，黑色对象不能引用白色对象，因为黑色对象代表它引用的所有对象都已经变成灰色或者黑色对象，与这个约定相互矛盾。这就是一个约束条件，write barrier就是要维护这条约束。

Golang 1.7 之前的 write barrier 使用的经典的Dijkstra-style insertion write barrier [Dijkstra ‘78]， STW 的主要耗时就在 stack re-scan 的过程。自1.8 之后采用一种混合的写屏障（Hybrid Write Barrier）方式，大幅减少了re-scan时第二次STW的时间。

#### 清扫（sweep）

内存管理都是基于 span 的，mheap_ 是一个全局的变量，所有分配的对象都会记录在 mheap_ 中。在标记的时候，我们只要找到对对象对应的 span 进行标记，清扫的时候扫描 span，没有标记的 span 就可以回收了。

#### 总结

1. 三色（白、灰、黑）标记法进行GC，白色对象最终被清除
2. 从root对象开始遍历，包括全局指针和goroutine指针
3. 写屏障记录有Mark期间新分配的对象
4. 两次STW：准备工作；re-scan
5. 核心：抑制堆增长，充分利用CPU，减少STW

### 延迟vs吞吐

Go的垃圾收集器是和主程序并行的，程序逻辑和GC过程应该是交替占用CPU资源的，这就可以避免程序的长时间暂停。

这种并行GC能够实现低延迟，但是低延迟削减了吞吐量。并发需要额外的同步和赋值操作，而这些操作将会占用程序的处理逻辑的时间。对于推送系统这种实时性要求比较高的系统，选择Go语言则是合适的选择。

### 何时触发GC

1. 主动检测：
   - 根据当前与上次的heap size的比例来决定，默认情况下是100，即新增一倍就会触发（GOGC设置）
   - 超过两分钟没有GC，则触发GC
2. 用户调用：上面是自动垃圾回收，还有一种是主动垃圾回收，通过调用 runtime.GC()，这是阻塞式的。

### 如何测量GC

golang中的gc是使用标记清楚法，所以gc的总时间为：

> Tgc = Tseq + Tmark + Tsweep(T表示time)

Tseq表示是停止用户的 goroutine 和做一些准备活动（通常很小）需要的时间

Tmark 是堆标记时间，标记发生在所有用户 goroutine 停止时，因此可以显著地影响处理的延迟

Tsweep 是堆清除时间，清除通常与正常的程序运行同时发生，所以对延迟来说是不太关键的

- 与Tmark相关的：
  1. 垃圾回收过程中，堆中活动对象的数量，
  2. 带有指针的活动对象占据的内存总量 
  3. 活动对象中的指针数量。 

- 与Tsweep相关的：
  1. 堆内存的总量
  2. 堆中的垃圾总量

### GC调优策略

1. 权衡：“ 如果你想减少在GC上花费的总时间，增加GOGC，但是内存必须足够大。 如果你的内存少，你只能用更频繁的GC时间以节省内存，那么降低GOGC值'。

   > GOGC 参数主要控制的是**下一次gc开始的时候的内存使用量**
   >
   > 比如当前的程序使用了 4M 的对内存（这里说的是**堆内存**），即是说程序当前 reachable 的内存为 4M，当程序占用的内存达到 reachable*(1+GOGC/100)=8M 的时候，gc 就会被触发，开始进行相关的 gc 操作。

2. 假如一直没有内存分配没达到阈值，则只能等待2分钟才能被触发GC，此时可以采取某种策略主动触发GC

## 实践经验

### 监控GC

#### 本地环境

在程序执行之前加上环境变量`GODEBUG=gctrace=1` ，

 `GODEBUG=gctrace=1 ./xxxx` 或`GODEBUG=gctrace=1 go run main.go` 的方式输出GC信息（输出到stderr）：

![gc_info](http://holys.im/images/gc_info.png)

**垃圾回收信息：**

```shell
gc 1 @2.104s 0%: 0.018+1.3+0.076 ms clock, 0.054+0.35/1.0/3.0+0.23 ms cpu, 4->4->3 MB, 5 MB goal, 4 P
```

 `1` 表示第一次执行GC

 `@2.104s` 表示程序执行的总时间 `0%` 垃圾回收时间占用的百分比，

 `0.018+1.3+0.076 ms clock` 垃圾回收的时间，分别为0.018ms**STW**（stop-the-world）清扫的时间, 1.3ms并发标记和扫描的时间，0.076ms**STW**标记的时间 

`0.054+0.35/1.0/3.0+0.23 ms cpu` 垃圾回收占用cpu时间, 0.054ms**STW**清扫占用的cpu时间，0.35ms辅助时间，1.0ms后台gc时间，3.0ms空闲gc时间，**STW**标记终止时间。

`4->4->3 MB` 堆的大小，gc后堆的大小，存活堆的大小 

`5 MB goal` 整体堆的大小

 `4 P` GC使用的处理器数量

**系统内存回收信息：**

```shell
scvg0: inuse: 426, idle: 0, sys: 427, released: 0, consumed: 427 (MB)
```

`426` 使用多少M内存
`0` 剩下要清除的内存
`427` 系统映射的内存
`0` 释放的系统内存
`427` 申请的系统内存

**gcvis：**

[gcvis](https://github.com/davecheney/gcvis)用于GC信息的可视化。

gcvis 的原理很简单， 就是逐行解析目标程序的 GC 输出，然后用正则匹配相关的数据，然后生成 JSON 数据，另外也会起一个协程开启 HTTP 服务，用于图表展示。

gcvis 主要有两种用法：

1、 直接运行

```
gcvis /path/to/binary
```

2、 管道重定向方式（standard error）

```
GODEBUG=gctrace=1  /path/to/binary  |& gcvis
```

gcvis 的图标输出效果如下：

[![3BBEB93C-2129-4FB8-ADBE-509CB4489D63](http://holys.im/images/3BBEB93C-2129-4FB8-ADBE-509CB4489D63.png)](http://holys.im/images/3BBEB93C-2129-4FB8-ADBE-509CB4489D63.png)

#### 线上环境

上面这种是不修改一行代码的情况下，完全使用外部工具/参数，无侵入式的GC监控。 另一种办法是直接读取 `runtime.MemStats` (runtime/mstats.go) 的内容。其实上面这种办法也是读取了 `runtime.memstats` (跟 `runtime.MemStats` 是同一个东西，一个对内，一个对外)。

有不少开源项目这么干的：

1. NSQ 对 GC 监控 <https://github.com/nsqio/nsq/blob/master/nsqd/statsd.go#L117>
2. beego 对 GC 的监控： <https://github.com/astaxie/beego/blob/master/toolbox/profile.go#L96

### 常见问题

#### go程序内存占用大的问题

这个问题在我们对后台服务进行压力测试时发现，我们模拟大量的用户请求访问后台服务，这时各服务模块能观察到明显的内存占用上升。但是当停止压测时，内存占用并未发生明显的下降。花了很长时间定位问题，使用pprof等各种方法，依然没有发现原因。最后发现原来这时正常的…主要的原因有两个，

一是go的垃圾回收有个触发阈值，这个阈值会随着每次内存使用变大而逐渐增大（如初始阈值是10MB则下一次就是20MB，再下一次就成为了40MB…），如果长时间没有触发gc go会主动触发一次（2min）。高峰时内存使用量上去后，除非持续申请内存，靠阈值触发gc已经基本不可能，而是要等最多2min主动gc开始才能触发gc。

第二个原因是go语言在向系统交还内存时只是告诉系统这些内存不需要使用了，可以回收；同时操作系统会**采取“拖延症”策略，并不是立即回收，而是等到系统内存紧张时才会开始回收**这样该程序又重新申请内存时就可以获得极快的分配速度。

#### gc时间长的问题

对于对用户响应事件有要求的后端程序，golang gc时的stop the world兼职是噩梦。根据上文的介绍，1.5版本的go再完成上述改进后应该gc性能会提升不少，但是所有的垃圾回收型语言都难免在gc时面临性能下降，对此我们对于应该尽量避免频繁创建临时堆对象（如&abc{}, new, make等）以减少垃圾收集时的扫描时间，对于需要频繁使用的临时对象考虑直接通过数组缓存进行重用；很多人采用cgo的方法自己管理内存而绕开垃圾收集，这种方法除非迫不得已个人是不推荐的（容易造成不可预知的问题），当然迫不得已的情况下还是可以考虑的，这招带来的效果还是很明显的~

#### goroutine泄露的问题

我们的一个服务需要处理很多长连接请求，实现时，对于每个长连接请求各开了一个读取和写入协程，全部采用endless for loop不停地处理收发数据。当连接被远端关闭后，如果不对这两个协程做处理，他们依然会一直运行，并且占用的channel也不会被释放…这里就必须十分注意，在不使用协程后一定要把他依赖的channel close并通过再协程中判断channel是否关闭以保证其退出。

## 参考

[Go语言的实时GC——理论与实践](https://segmentfault.com/a/1190000010753702)

[golang 垃圾回收机制](https://lengzzz.com/note/gc-in-golang)

[Golang 垃圾回收剖析](http://legendtkl.com/2017/04/28/golang-gc/)

[Golang GC 垃圾回收机制详解](https://blog.csdn.net/u010649766/article/details/80582153)

[如何监控 golang 程序的垃圾回收](http://holys.im/2016/07/01/monitor-golang-gc/)
