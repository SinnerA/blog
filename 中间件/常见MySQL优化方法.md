---
title: 常见MySQL优化方法
date: 2018-08-18
tags: 
    - mysql
---

[TOC]

## 概述

数据库优化的几个方面：SQL语句以及有效索引、数据结构、系统配置、硬件

![img](https://pic2.zhimg.com/80/v2-175a3346c893bca13849da4d91e7dfbd_hd.jpg)

1. SQL以及索引的优化是最重要的。首先要根据需求写出**结构良好**的SQL，然后根据SQL在表中建立**有效的**索引。但是如果索引太多，不但会影响写入的效率，对查询也有一定的影响。
2. 要根据一些范式来进行表结构的设计。设计表结构时，就需要考虑如何设计才能够更有效的查询。
3. 系统配置的优化。MySQL数据库是基于文件的，如果打开的文件数达到一定的数量，无法打开之后就会进行频繁的IO操作。
4. 硬件优化。更快的IO、更多的内存。一般来说内存越大，对于数据库的操作越好。但是**CPU多就不一定了，因为他并不会用到太多的CPU数量，有很多的查询都是单CPU**。另外使用高的IO（SSD、RAID），但是IO并不能减少数据库锁的机制。所以说如果查询缓慢是因为数据库内部的一些锁引起的，那么硬件优化就没有什么意义。

## SQL语句及索引

### SQL语句

#### 分析工具

##### 慢查询日志

可以通过开启慢查询日志的方式进行定位有问题的SQL

（1）查看MySQL是否开启慢查询日志

```sql
show variables like 'slow_query_log';
```

![img](https://nos.netease.com/cloud-website-bucket/201808031001558f03e31b-1e59-46ac-af77-999cc25141bb.png)

（2）设置没有索引的记录到慢查询日志

```sql
set global log_queries_not_using_indexes=on;
```

（3）查看超过多长时间的sql进行记录到慢查询日志

```sql
show variables like 'long_query_time'
```

（4）开启慢查询日志

```sql
set global slow_query_log=on
```

（5）设置超时时间

```sql
set global long_query_time=5; --超过5s的语句才记录日志
```

（6）查看慢查询日志的位置

```sql
show variables like 'slow%'
```

![img](https://nos.netease.com/cloud-website-bucket/2018080310021085beb879-6d15-459e-aea5-036f2b74c9a5.png) 

（7）慢查询日志分析：

![慢查询日志](http://tektea-img.b0.upaiyun.com/blog/2017/07/6.webp_21.jpg)

第一行：标记日志产生的时间，准确说是SQL执行完成的时间点，改行记录每一秒只打印一条。

第二行：客户端的账户信息，两个用户名（第一个是授权账户，第二个为登录账户），客户端IP地址，还有mysqld的线程ID。

第三行：查询执行的信息，包括查询时长，锁持有时长，返回客户端的行数，扫描行数。通常我需要优化的就是最后一个内容，**尽量减少SQL语句扫描的数据行数**。

第四行：通过代码看，貌似和第一行的时间没有区别。

第五话：最后就是产生慢查询的SQL语句。

可以利用MySQL自带的慢查询日志分析工具mysqldumpslow分析慢查询日志

##### explain

MySQL EXPLAIN命令是查询性能优化不可缺少的一部分，可以得到mysql执行sql语句的一些细节：

| 列名          | 说明                                                         |
| ------------- | ------------------------------------------------------------ |
| id            | 执行编号，标识select所属的行。如果在语句中没子查询或关联查询，只有唯一的select，每行都将显示1。否则，内层的select语句一般会顺序编号，对应于其在原始语句中的位置 |
| select_type   | 显示本行是简单或复杂select。如果查询有任何复杂的子查询，则最外层标记为PRIMARY（DERIVED、UNION、UNION RESUlT） |
| table         | 访问引用哪个表（引用某个查询，如“derived3”）                 |
| type          | 数据访问/读取操作类型（ALL、index、range、ref、eq_ref、const/system、NULL） |
| possible_keys | **揭示哪一些索引可能有利于高效的查找**                       |
| key           | **显示mysql决定采用哪个索引来优化查询**                      |
| key_len       | **显示mysql在索引里使用的字节数** （对于联合索引来说，留意下这个列的值，算一下你的多列索引总长度就知道有没有使用到所有的列了。） |
| ref           | **显示了之前的表在key列记录的索引中查找值所用的列或常量**    |
| rows          | 为了找到所需的行而需要读取的行数，估算值，不精确。通过把所有rows列值相乘，可粗略估算整个查询会检查的行数 |
| Extra         | 额外信息，如using index、filesort等                          |

#### 优化步骤

1. 通过show status命令了解各种SQL的执行频率；
2. 定位执行效率较低的SQL语句-（重点select；
3. 通过explain分析低效率的SQL；
4. 确定问题并采取相应的优化措施。

#### 一般建议

1. select必须制定字段名称，*增加了不必要数据的IO，以及降低了使用覆盖索引的可能性

2. 尽量使用limit

3. in和between：对于连续的数值，能用between就不要用in了。between等价于>=和<=，只需要匹配上下界就行，时间复杂度为O(n)，mysql对in做了优化，存储在有序数组中，因此采用二分查找，复杂度为O(lgn)

4. 用exists代替in

5. 避免全表扫描的行为：

   - 避免在 `where` 子句中使用`!=`或`<>`操作符

   - 避免使用NULL

   - 避免在 `where` 子句中使用 `or` 来连接条件，可以使用union all

     ```sql
     select id from t where num=10 or num=20
     
     select id from t where num=10 union all select id from t where num=20
     ```

   - 避免在使用like时，使用前置%

   - 避免使用局部变量、表达式或函数，因为只有在运行时才会解析局部变量

### 索引

#### 选择索引

1. 选择合适的索引列 ，选择在where，group by，order by，on从句中出现的列作为索引项，对于离散度不大的列没有必要创建索引。
2. 索引字段越小越好(因为数据库的存储单位是页，一页中能存下的数据越多越好 )，适当时候使用前缀索引
3. 离散度大的列放在联合索引前面

#### 索引优化

1. 尽量在InnoDB上采用自增字段做主键，因为有序，维护主键索引代价小
2. 联合索引遵循最左前缀原则
3. 索引长度太长时，可以考虑使用前缀索引，但要保证一定的选择性

## 数据库设计

### 符合三范式（3NF）

1. 1NF是对属性的原子性约束，要求属性(列)具有原子性，不可再分解；(只要是关系型数据库都满足1NF)
2. 2NF是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性；
3. 3NF是对字段冗余性的约束，它要求字段没有冗余。 

### 分库分表

#### 垂直拆分

##### 分表

垂直分表比较常见，就是“大表拆小表”，拆分是基于关系型数据库中的“列”（字段）进行的。通常情况，某个表中的字段比较多，可以新建立一张“扩展表”，将不经常使用或者长度较大的字段拆分出去放到“扩展表”中。

拆分字段的操作建议在数据库设计阶段就做好。如果是在发展过程中拆分，则需要改写以前的查询语句，会额外带来一定的成本和风险。

##### 分库

垂直分库在“微服务”盛行的今天已经非常普及了。基本的思路就是按照业务模块来划分出不同的数据库，而不是像早期一样将所有的数据表都放到同一个数据库中。

##### 分库分表

垂直分库分表就是将本来可以在同一个表中的内容人为地划分为多个表，并且放到不同的数据库中。所谓“本来”，是指按照关系型数据库第三范式的要求，应该在同一个表中，将其拆分开就叫作反范化（Denormalize）。

典型的场景就是用于实现冷热分离，我把冷热数据分开存放，就叫作冷热分离，在MySQL的数据库中，冷数据查询较多，更新较少，适合用MyISAM引擎，而热数据更新比较频繁，适合使用InnoDB存储引擎。

当然热点数据也可以使用缓存，然后lazy更新到mysql中。

举个例子：在微博系统的设计中，一个微博对象包括文章标题、作者、分类、创建时间等属性字段，这些字段的变化频率低，查询次数多，叫作冷数据。而博客的浏览量、回复数、点赞数等类似的统计信息，或者别的变化频率比较高的数据，叫作活跃数据或者热数据。

#### 水平拆分

##### 分表

水平分表也称为横向分表，比较容易理解，就是将表中不同的数据行按照一定规律分布到不同的数据库表中（这些表保存在同一个数据库中），这样来降低单表数据量，优化查询性能。最常见的方式就是通过**主键或者时间等字段**进行Hash和取模后拆分。

但本质上这些表还保存在同一个库中，所以库级别还是会有IO瓶颈。所以，一般不建议采用这种做法。

##### 分库分表

水平分库分表与上面讲到的水平分表的思想相同，唯一不同的就是将这些拆分出来的表保存在不同的数据库中。这也是很多大型互联网公司所选择的做法。

水平分库分表能有效减少单个数据库压力。

常见拆分维度：

- **按照某个字段hash**：好处是数据切片比较均匀，对数据压力分散的效果较好，缺点是数据分散后，对于查询需求需要进行聚合处理。
- **按照时间段切片**：按照时间进行切片，针对不同的访问频率使用不同档次的硬件资源来节省成本，针对最近时间段的（访问频繁）的使用较好的硬件。
- **两者结合**：对数据先按照时间段进行切片，然后对于某一季度的数据按照主键哈希进行切片。

####挑战

在高并发和海量数据的场景下，分库分表能够有效缓解单机和单库的性能瓶颈和压力，突破IO、连接数、硬件资源的瓶颈。但是也带来了一些挑战：

垂直拆分会带来了跨库join，分布式事务等问题。

水平拆分也会带来跨分片的复杂查询，跨分片事务等问题。

##### 跨库join

**全局表**

所谓全局表，就是有可能系统中所有模块都可能会依赖到的一些表。比较类似我们理解的“数据字典”。为了避免跨库join查询，我们可以将这类表在其他每个数据库中均保存一份。同时，这类数据通常也很少发生修改（甚至几乎不会），所以也不用太担心“一致性”问题。

**字段冗余**

这是一种典型的反范式设计，在互联网行业中比较常见，通常是为了性能来避免join查询。

举个例子：“订单表”中保存“卖家Id”的同时，将卖家的“Name”字段也冗余，这样查询订单详情的时候就不需要再去查询“卖家用户表”。

**业务层组装数据**

在系统层面，通过调用不同模块的组件或者服务，获取数据并进行字段拼装。

##### 跨库事务

按业务拆分数据库之后，不可避免的就是“分布式事务”的问题。

这块内容较多，可以参考：[分布式系统事务一致性解决方案](http://www.infoq.com/cn/articles/solution-of-distributed-system-transaction-consistency)

### 读写分离

读写分离是指让主库处理事务性查询和写入，而从库处理SELECT查询。数据库复制被用来把主库导致的数据变更同步到集群中的从库中，采用异步读取binlog来同步数据。

读写分离适合**读多写少**的场景。

####为何高效

1. 物理服务器增加，负荷增加
2. 主从只负责各自的写和读，极大程度的缓解X锁和S锁争用
3. 从库可配置myisam引擎，提升查询性能以及节约系统开销
4. 从库同步主库的数据和主库直接写还是有区别的，通过主库发送来的binlog恢复数据，但是，最重要区别在于主库向从库发送binlog是异步的，从库恢复数据也是异步的
5. 读写分离适用与读远大于写的场景，如果只有一台服务器，当select很多时，update和delete会被这些select访问中的数据堵塞，等待select结束，并发性能不高。 对于写和读比例相近的应用，应该部署双主相互复制
6. 可以在从库启动是增加一些参数来提高其读的性能，例如--skip-innodb、--skip-bdb、--low-priority-updates以及--delay-key-write=ALL。当然这些设置也是需要根据具体业务需求来定得，不一定能用上
7. 分摊读取。假如我们有1主3从，不考虑上述1中提到的从库单方面设置，假设现在1 分钟内有10条写入，150条读取。那么，1主3从相当于共计40条写入，而读取总数没变，因此平均下来每台服务器承担了10条写入和50条读取（主库不 承担读取操作）。因此，虽然写入没变，但是读取大大分摊了，提高了系统性能。另外，当读取被分摊后，又间接提高了写入的性能。所以，总体性能提高了，说白 了就是拿机器和带宽换性能。MySQL官方文档中有相关演算公式：[官方文档](http://dev.mysql.com/doc/refman/5.1/zh/replication.html#replication-faq) 见6.9FAQ之“MySQL复制能够何时和多大程度提高系统性能”
8. MySQL复制另外一大功能是增加冗余，提高可用性，当一台数据库服务器宕机后能通过调整另外一台从库来以最快的速度恢复服务，因此不能光看性能，也就是说1主1从也是可以的。

## 数据库配置

mysql数据库配置（my.ini文件）主要关注两点：

1. 最大并发数
2. 调整各种缓存的大小

### 连接数（max_connections）

max_connections 可以设置最大并发连接数。当MySql的并发连接达到这个设定值时，新的连接将会被拒绝（“Can not connect to MySQL server. Too many connections”-mysql 1040错误）。当发现MySql有能力处理更多的并发的时候， 建议调大这个值，相应给服务器带来更高的负载(CPU/IO/内存)。

```sql
mysql> show variables like 'max_connections';
+-----------------+-------+
| Variable_name | Value |
+-----------------+-------+
| max_connections | 151 | 允许的最大连接数
+-----------------+-------+
 
show status like 'threads_connected'; --看当前连接数
show status like "max_used_connections"; --最大连接数
```

如果max_used_connections已经接近 max_connections了，就说明max_connections太小。不合适了。

还有个back_log，表示MySQL能暂存的连接数量。

### innodb的索引和数据缓冲区（innodb_buffer_pool_size）

innodb_buffer_pool_size表示InnoDB缓冲池的字节数。InnoDB缓冲池用于多个目的：

* 数据缓存 – 这绝对是它的最重要的目的
* 索引缓存 – 这使用是的同一个缓冲池
* 缓冲 – 更改的数据(通常称为脏数据)在被刷新到硬盘之前先存放到缓冲
* 存储内部结构 – 一些结构如自适应哈希索引或者行锁也都存储在InnoDB缓冲池

innodb_buffer_pool_size默认为128M，值较小。

如果服务器专用mysql的话，可以设置为操作系统内存的70%-80%。

并不是设置的越大越好。设置的过大，会导致system的swap空间被占用，导致操作系统变慢，从而减低sql查询的效率。

### 索引缓冲区（key_buffer_size）

key_buffer_size指定索引缓冲区的大小，它决定索引处理的速度，尤其是**索引读的速度**。通过检查状态值Key_read_requests和Key_reads，可以知道key_buffer_size设置是否合理。比例key_reads /key_read_requests应该尽可能的低，至少是1:100，1:1000更好。

> Key_read_requests：从缓存读取索引的请求次数。 Key_reads：从磁盘读取索引的请求次数。

### 查询缓存（query_cache）

查询缓存就是内存中的一块存储区域，其存储了用户的SQL文本以及相关的查询结果。通常情况下，用户下次查询时，如果所使用的SQL文本是相同的，并且自从上次查询后，相关的纪录没有被更新过，此时数据库就直接采用缓存中的内容。从内存中读取要比从硬盘上速度要快好几百倍。

要使用缓存，有几个条件：

1. 所采用的SQL语句是相同的。
2. 表数据没有改过。没有改过结构，没有update，insert
3. 客户端与服务器的默认字符集得一样

### 临时表缓存(tmp_table_size)

mysql进行复杂查询或者 做高级GROUP BY操作的时候，系统为了优化查询，生成一些临时表。通过设置tmp_table_size选项来设置临时表占用空间的大小。

我们使用explain分析SQL，如果在Extra列看到Using temporary就意味着使用了临时表。

## 硬件

硬件层面的优化是最后的手段。主要需考虑CPU、存储、网络等几个方面。

1. CPU：CPU并不是越多越好，之前看到网上的分析有说很多的查询都是单CPU的，增加CPU数量并不能提高性能。
2. 存储：机械磁盘 or SSD（当然是SSD更快）；单个大磁盘 or 多个小磁盘组合使用（单个1T的磁盘应该没有2个500G磁盘的组合快，因为磁盘的转速都是固定的，两个磁盘相当于可以并行的读取）
3. 网络：一般不是问题，但是在分布式的集群环境中，各个数据库节点之间的网络环境经常会称为系统的瓶颈。另外，如果服务端和数据库分布在不同的城市，一条简单SQL传输的时间可能就要几十毫秒。

## 参考

[MySQL数据库优化两三事](https://sq.163yun.com/blog/article/183654375478206464)

[mysql数据库的安装以及常见优化设置](https://www.cnblogs.com/hunhunrensheng/p/3782596.html)

[分库分表的几种常见形式以及可能遇到的难](http://www.infoq.com/cn/articles/key-steps-and-likely-problems-of-split-table)

[关于分库分表，这有一套大而全的轻量级架构设计思路](http://dbaplus.cn/news-141-2017-1.html)

[MySQL 读写分离](https://blog.csdn.net/justdb/article/details/17331569)
