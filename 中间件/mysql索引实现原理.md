---
title: mysql索引实现原理
date: 2018-06-26
tags: 
    - mysql
---

[TOC]

## 数据结构

索引用于查找数据，因此需要采用高效的数据结构，首先想到的是二分查找，但是二分查找的话，需要把整个索引加载到内存，索引大的话可能有几个G，因此不能采用简单的二分查找。

其次，会想到二叉查找树，查找效率是O(logN)，但是二叉查找树在极端情况下回退化为线性查找。

AVL树是平衡的二叉查找树，可以保证查找效率，不过在插入删除的时候需要调整节点用于维护平衡状态。但是AVL树还是有问题，因为索引节点一旦变多，会导致AVL树的树高很高，而每加载一个节点都需要进行一次磁盘IO，所以树高很高会导致磁盘IO耗时很大。

因此，要想达到减少磁盘IO次数的目的，需要尽量让树的节点装载更多的信息，并且树高越低越好，这正是B树(Balance Tree，多路自平衡的搜索树)。

MySQL索引采用的是B+树，B+树是B树的改进版。

B树与B+树的区别：

1. B树：所有键值分布在整颗树中；在关键字全集内做一次查找,性能逼近二分查找；
2. B+树：所有关键字存储在叶子节点出现,内部节点(非叶子节点并不存储真正的 data)；为所有叶子结点增加了一个链指针

索引选用B+树的原因：

1. B+树更适合外部存储,由于内节点无 data 域,一个结点可以存储更多的内结点,每个节点能索引的范围更大更精确,也意味着 B+树单次磁盘IO的信息量大于B-树,I/O效率更高。
2. Mysql是一种关系型数据库，区间访问是常见的一种情况，B+树叶节点增加的链指针,加强了区间访问性，可使用在范围区间查询等，而B-树每个节点 key 和 data 在一起，则无法区间查找。

> 红黑树与AVL树类似，索引也不会采用红黑树。
>
> 红黑树牺牲了严格平衡，采用相对平衡的方式，能够以O(log2 N) 的时间复杂度进行搜索、插入、删除操作。相比AVL树，红黑树搜索会更慢（树更高），旋转次数会更少导致插入删除会更快（非严格平衡）。总体效率更高些。

## MySQL索引实现

### MyISAM

MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。下图是MyISAM索引的原理图：

![img](http://blog.codinglabs.org/uploads/pictures/theory-of-mysql-index/8.png)

​											图8

这里设表一共有三列，假设我们以Col1为主键，则图8是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：

![img](http://blog.codinglabs.org/uploads/pictures/theory-of-mysql-index/9.png)

​											图9

同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。

MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。

### InnoDB

虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。

第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。

而**在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构**，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此**InnoDB表数据文件本身就是主索引**。

![img](http://blog.codinglabs.org/uploads/pictures/theory-of-mysql-index/10.png)

​											图10

图10是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为**InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有）**，如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表**生成一个隐含字段作为主键**，这个字段长度为6个字节，类型为长整形。

第二个与MyISAM索引的不同是：**InnoDB的辅助索引data域存储相应记录主键的值而不是地址。**

换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，图11为定义在Col3上的一个辅助索引：

![img](http://blog.codinglabs.org/uploads/pictures/theory-of-mysql-index/11.png)

​											图11

这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。

了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助。例如知道了InnoDB的索引实现后，就很容易明白为什么**不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大**。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，**非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整**，十分低效，而使用自增字段作为主键则是一个很好的选择。

### 索引类型

注意，经常我们会提到普通索引、唯一索引、前缀索引和联合索引，其实这些都是上面提到的辅助索引（也叫二级索引）。

**普通索引**

普通索引（由关键字KEY或INDEX定义的索引）的唯一任务是加快对数据的访问速度。因此，应该只为那些最经常出现在查询条件（WHEREcolumn=）或排序条件（ORDERBYcolumn）中的数据列创建索引。只要有可能，就应该选择一个数据最整齐、最紧凑的数据列（如一个整数类型的数据列）来创建索引。

**唯一索引**

普通索引允许被索引的数据列包含重复的值。如果能确定某个数据列将只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字UNIQUE把它定义为一个唯一索引。

唯一索引的好处：一是简化了MySQL对这个索引的管理工作，这个索引也因此而变得更有效率；二是在插入时，MySQL将拒绝插入重复新记录。也就是说，唯一索引可以保证数据记录的唯一性。事实上，在许多场合，人们创建唯一索引的目的往往不是为了提高访问速度，而只是为了避免数据出现重复。

主键索引是唯一索引的一种特殊类型。

**联合索引**

联合索引，又叫复合索引，由两个或更多个列上的索引组成。对于联合索引，Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。例如建了一个(a,b,c)的复合索引，可以支持(a),(a,b),(a,b,c)3种组合进行查找，但不支持(b,c)进行查找。当最左侧字段是常量引用时，索引就十分有效。

联合索引的好处：

1. "一个顶三个"。建了一个(a,b,c)的复合索引，那么实际等于建了(a),(a,b),(a,b,c)三个索引，因为每多一个索引，都会增加写操作的开销和磁盘空间的开销。对于大量数据的表，这可是不小的开销！

2. 覆盖索引。同样的有复合索引（a,b,c），如果有如下的sql: select a,b,c from table where a=1 and b = 1。那么MySQL可以直接通过遍历索引取得数据，这减少了很多的IO操作。所以，在真正的实际应用中，覆盖索引是主要的提升性能的优化手段之一。

   > 覆盖索引，select的数据列只用从索引中就能够取得，不必读取数据行。

3. 索引列越多，通过索引筛选出的数据越少。有1000W条数据的表，有如下sql：select * from table where a = 1 and b =2 and c = 3，假设假设每个条件可以筛选出10%的数据，如果只有单值索引，那么通过该索引能筛选出1000W*10%=100w 条数据，然后再回表从100w条数据中找到符合b=2 and c= 3的数据，然后再排序，再分页；如果是复合索引，通过索引筛选出1000w *10% *10% *10%=1w，然后再排序、分页，哪个更高效，一眼便知。

在实际项目中，联合索引的使用要远多于单列索引。

**前缀索引**

前缀索引，就是用列的前缀代替整个列作为索引key，当前缀长度合适时，可以做到既使得前缀索引的选择性接近全列索引，同时因为索引key变短而减少了索引文件的大小和维护开销。

> 所谓索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数（#T）的比值。选择性越高的索引价值越大，这是由B+Tree的性质决定的。

前缀索引兼顾索引大小和查询速度，但是其缺点是不能用于ORDER BY和GROUP BY操作，也不能用于Covering index（即当索引本身包含查询所需全部数据时，不再访问数据文件本身）。

**index merge**

参考：http://www.orczhou.com/index.php/2013/01/mysql-source-code-query-optimization-index-merge/

## 策略及优化

MySQL的优化主要分为结构优化（Scheme optimization）和查询优化（Query optimization）。这里讨论的高性能索引策略主要属于结构优化范畴。

MySQL EXPLAIN命令是查询性能优化不可缺少的一部分，可以查看mysql执行sql语句的一些细节：

| 列名          | 说明                                                         |
| ------------- | ------------------------------------------------------------ |
| id            | 执行编号，标识select所属的行。如果在语句中没子查询或关联查询，只有唯一的select，每行都将显示1。否则，内层的select语句一般会顺序编号，对应于其在原始语句中的位置 |
| select_type   | 显示本行是简单或复杂select。如果查询有任何复杂的子查询，则最外层标记为PRIMARY（DERIVED、UNION、UNION RESUlT） |
| table         | 访问引用哪个表（引用某个查询，如“derived3”）                 |
| type          | 数据访问/读取操作类型（ALL、index、range、ref、eq_ref、const/system、NULL） |
| possible_keys | **揭示哪一些索引可能有利于高效的查找**                       |
| key           | **显示mysql决定采用哪个索引来优化查询**                      |
| key_len       | **显示mysql在索引里使用的字节数** （对于联合索引来说，留意下这个列的值，算一下你的多列索引总长度就知道有没有使用到所有的列了。） |
| ref           | **显示了之前的表在key列记录的索引中查找值所用的列或常量**    |
| rows          | 为了找到所需的行而需要读取的行数，估算值，不精确。通过把所有rows列值相乘，可粗略估算整个查询会检查的行数 |
| Extra         | 额外信息，如using index、filesort等                          |

### 常见优化

1. select必须制定字段名称，*增加了不必要数据的IO，以及降低了使用覆盖索引的可能性

2. 尽量使用limit

3. in和between：对于连续的数值，能用between就不要用in了。between等价于>=和<=，只需要匹配上下界就行，时间复杂度为O(n)，mysql对in做了优化，存储在有序数组中，因此采用二分查找，复杂度为O(lgn)

4. 用exists代替in

5. 避免全表扫描的行为：

   - 避免在 `where` 子句中使用`!=`或`<>`操作符

   - 避免使用NULL

   - 避免在 `where` 子句中使用 `or` 来连接条件，可以使用union all

     ```sql
     select id from t where num=10 or num=20
     
     select id from t where num=10 union all select id from t where num=20
     ```

   - 避免在使用like时，使用前置%

   - 避免使用局部变量、表达式或函数，因为只有在运行时才会解析局部变量

6. 索引优化：

   - 最左前缀原理：联合索引中遵循最左前缀索引匹配原则，即从左到右依次匹配
     - like "xxx%"可以使用到索引，但like "%xxx%"无法使用索引
     - 联合索引最多应用于一个范围列
   - 索引选择性与前缀索引：选择性较低的没必要建索引，兼顾长度和选择性可以选择前缀索引
   - 尽量在InnoDB上采用自增字段做主键：因为自增主键，每次插入新纪录都会顺序添加索引，不需要移动其他索引，维护主键索引开销小

## 参考

[漫画算法：什么是 B 树？](http://blog.jobbole.com/111757/)

[MySQL索引总结](https://zhuanlan.zhihu.com/p/29118331)

[由 B-/B+树看 MySQL索引结构](https://segmentfault.com/a/1190000004690721)

[MySQL索引背后的数据结构及算法原理](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)
