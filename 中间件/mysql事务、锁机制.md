---
title: mysql事务、锁机制
date: 2018-06-26
tags: 
    - mysql
---

[TOC]

## 基本概念

### MVCC

MVCC全称是： **Multiversion concurrency control，多版本并发控制**，提供并发访问数据库时，对事务内读取的到的内存做处理，用来避免写操作堵塞读操作的并发问题。

举个例子，A正在读数据库中某些内容，而B正在给这些内容做修改（假设是在一个事务内修改，大概持续10s左右），A在这10s内 则可能看到一个不一致的数据，在B没有提交前，如何让A能够一直读到的数据都是一致的呢？

有几种处理方法，第一种： 基于锁的并发控制，程序员B开始修改数据时，给这些数据加上锁，程序员A这时再读，就发现读取不了，处于等待情况，只能等B操作完才能读数据，这保证A不会读到一个不一致的数据，但是这个会影响程序的运行效率。还有一种就是：MVCC，**每个用户连接数据库时，看到的都是某一特定时刻的数据库快照**，在B的事务没有提交之前，A始终读到的是某一特定时刻的数据库快照，不会读到B事务中的数据修改情况，直到B事务提交，才会读取B的修改内容。

一个支持MVCC的数据库，**在更新某些数据时，并非使用新数据覆盖旧数据，而是标记旧数据是过时的，同时在其他地方新增一个数据版本**。因此，同一份数据有多个版本存储，但只有一个是最新的。

同一份数据，既有读事务访问，又有写事务操作，实际上，写事务会新建一个新的数据版本，而读事务访问的是旧的数据版本，直到写事务提交，读事务才会访问到这个新的数据版本。

早期的数据库系统，只有读读之间可以并发，读写，写读，写写都要阻塞。引入MVCC之后，只有写写之间相互阻塞，其他三种操作都可以并行，这样大幅度提高了并发度。

#### InnoDB中的实现

在InnoDB中，会在每行数据后添加两个额外的隐藏的值来实现MVCC，这两个值一个记录这行数据何时被创建，另外一个记录这行数据何时过期（或者被删除）。 在实际操作中，存储的并不是时间，而是事务的版本号，每开启一个新事务，事务的版本号就会递增。 

注意：**MVCC只工作在REPEATABLE READ和READ COMMITED隔离级别下。**主要为RR服务，在

在可重读Repeatable reads事务隔离级别下：

- SELECT时，读取创建版本号<=当前事务版本号，删除版本号为空或>当前事务版本号。
- INSERT时，保存当前事务版本号为行的创建版本号
- DELETE时，保存当前事务版本号为行的删除版本号
- UPDATE时，插入一条新纪录，保存当前事务版本号为行创建版本号，同时设置当前事务版本号为原来记录的删除版本号

通过MVCC，虽然每行记录都需要额外的存储空间，更多的行检查工作以及一些额外的维护工作，但可以减少锁的使用，大多数读操作都不用加锁，读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行，也只锁住必要行。

在MVCC中，读操作分为两类：当前读和快照读。

- 当前读：返回最新记录，会加锁，保证该记录不会被其他事务修改；
- 快照读：读取的是记录的某个版本（有可能是最新版本也有可能是旧版本），不加锁。

### 两阶段锁

系统有大量的并发访问，为了预防死锁，一般应用中推荐使用一次封锁法，就是在方法的开始阶段，已经预先知道会用到哪些数据，然后全部锁住，在方法运行之后，再全部解锁。

mysql采用的是2-PL（Two Phase Locking），也就是两阶段锁，锁的操作分为两个阶段：加锁、解锁。先加锁，后解锁，不相交。加锁时，读操作会申请并占用S锁，写操作会申请并占用X锁，如果对所在记录加锁有冲突，那么会处于等待状态，知道加锁成功才惊醒下一步操作，这里可能会造成死锁。解锁时，也就是事务提交或者回滚的时候，这个阶段会释放该事务中所有的加锁情况，进行一一释放锁。

这种方式虽然可能会导致死锁，但是两段锁协议可以保证事务的并发调度是串行化（串行化很重要，尤其是在数据恢复和备份的时候）的。

## 事务

### ACID

- 原性性（Actomicity）：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。
- 一致性（Consistent）：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以操持完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。
- 隔离性（Isolation）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。
- 持久性（Durable）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。

### 数据不一致

相对于串行处理来说，并发事务处理能大大增加数据库资源的利用率，提高数据库系统的事务吞吐量，从而可以支持可以支持更多的用户。但并发事务处理也会带来一些问题，主要包括以下几种情况。

- 脏读：读取未提交事务中修改的数据，称为脏读。
- 丢失更新：多个更新操作并发执行，导致某些更新操作数据丢失
- 不可重复读：同个事务多次读取同一条存在的记录，但是读取的结构不一致，称之为不可重复读
- 幻读：同个事务多次读取某段范围内的数据，但是读取到底行数不一致的情况，称之为幻读。幻读由insert造成的，比如同一个事务内，select的时候数据不存在，但是之后再select发现数据存在，出现了幻觉。

### 隔离级别

- 未提交读(RU, Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据
- 提交读(RC, Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)
- 可重复读(RR, Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻读（注：**在MySQL的RR级别中，通过MVCC解决了幻读问题**）
- 串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞

一般情况下，用的较多的是RC和RR。InnoDB默认是RR级别，也就是说可以解决上面说的四种数据不一致问题。

很多人容易搞混不可重复读和幻读，确实这两者有些相似。但不可重复读重点在于update和delete，而幻读的重点在于insert。

如果使用锁机制来实现这两种隔离级别，在可重复读中，该sql第一次读取到数据后，就将这些数据加锁，其它事务无法修改这些数据，就可以实现可重复读了。但这种方法却无法锁住insert的数据，所以当事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据提交，这时事务A就会发现莫名其妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免。需要Serializable隔离级别 ，读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。

在InnoDB中，是通过MVCC来解决幻读问题的，从而避免加锁提高了并发，其实MVCC可以看做是一种乐观锁。

## 锁

MySQL中的锁是用来保障事务隔离级别的，这里讨论的是InnoDB中的锁。

在InnoDB中，有4种类型的锁：IX、X、IS及S锁，其说明如下：

| 类型 | 说明       | 场景                                                         |
| ---- | ---------- | ------------------------------------------------------------ |
| S    | 共享锁     | 行锁或表锁，针对于RS隔离级别的查询或添加Lock in share mode的SELECT查询而产生的锁 |
| X    | 排它锁     | 行锁或表锁，针对于update、delete、insert操作而产生的锁，select ... for update |
| IS   | 意向共享锁 | 表锁，在添加S锁之前对表添加IS锁                              |
| IX   | 意向排他锁 | 表锁，在添加X锁之前对表添加IX锁                              |

InnoDB行锁是通过索引上的索引项来实现的，这一点ＭySQL与Oracle不同，后者是通过在数据中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味者：**只有通过索引条件检索数据，InnoDB才会使用行级锁**，否则，InnoDB将使用表锁。

### 锁兼容情况

如果一个事务请求的锁模式与当前的锁兼容， InnoDB 就将请求的锁授予该事务； 反之， 如果两者不兼容，该事务就要等待锁释放。

#### 行锁兼容

![img](https://images2017.cnblogs.com/blog/608061/201710/608061-20171022180439099-2112128552.png)

#### 表锁兼容

![img](https://images2017.cnblogs.com/blog/608061/201710/608061-20171022180947927-732267059.png)

#### QA

**为什么S和X分为行锁和表锁？**

对于InnoDB表，在绝大部分情况下都应该使用行级锁，因为**事务和行锁**往往是我们之所以选择InnoDB表的理由。但在某些特殊事务中，也可以考虑使用表级锁（使用LOCK TALBES虽然可以给InnoDB加表级锁）：

- 事务需要更新大部分或全部数据，表又比较大，如果使用默认的行锁，将导致执行效率低。
- 事务涉及多个表，比较复杂，很可能引起死锁，造成大量事务回滚。这种情况也可以考虑一次性锁定事务涉及的表，从而避免死锁、减少数据库因事务回滚带来的开销。

当然，应用中这两种事务不能太多，否则，就应该考虑使用ＭyISAＭ表。

**引入意向表锁的目的？**

在没有意向锁的时候，如果事务T 需要给表 A 添加 一个S 表锁，那么就意味这这个表内部的每一行数据，都不能有X锁，才能够申请 S 表锁成功，如果表数据很多，一行行查找非常浪费加锁时间，这个时候，就出现了表意向锁，当表内部某些行发生 UPATE DELETE INSERT操作，则会对表 加上 一个意向 IX 表锁，这样 事务T在申请 表A的 S 表锁时，只需要检查 表 A 是否有 IX表锁，如果有，则意味内部有部分行数据持有X锁，则直接进入等待情况，如果表没有 IX表锁，则直接申请S表锁成功，这是一个**节约加锁时间**的操作。

### 锁的级别

**Table Lock**

表锁，如果没有where条件、无可用索引或者获取的行记录过多，则会使用 table full scan，添加表锁

**Record Lock**

记录锁（行锁），如果执行计划使用了索引，则会根据索引的查找情况添加行锁

**Gap Lock**

在RR、RS隔离级别，发生在索引值之间，在连续的两个索引值之间添加锁，加锁后，这两个索引值之间，无法插入新的索引值，不包含行记录

该锁是避免幻读的一种手段，因为范围内无法插入新值，就不会出现幻读。

**Next-Key Lock**

也就是所谓的NEXT-KEY 锁，包含记录本身及记录之前的GAP。当前 MySQL 默认情况下使用RR的隔离级别，而NEXT-KEY LOCK正是为了解决RR隔离级别下的幻读问题。所谓幻读就是一个事务内执行相同的查询，会看到不同的行记录。在RR隔离级别下这是不允许的。

#### 应用

RR级别下，读分为当前读和快照读

- 快照读：
  - select * from table ....;
- 当前读：特殊的读操作，插入/更新/删除操作，属于当前读，处理的都是当前的数据，需要加锁。
  - select * from table where ? lock in share mode;
  - select * from table where ? for update;
  - insert;
  - update ;
  - delete;

RR级别下，解决了幻读问题，快照读是通过MVCC解决的，而在当前读中就是通过**Next-Key Lock**解决的，就是锁住一个索引区间，不允许其他事务插入新数据。

### 锁与隔离级别

注：这里不考虑 lock in shar mode跟for update

- RU，读未提交记录，不加锁读，正常写锁；
- RC，快照读，无锁；当前读，加 Record Lock
- RR，快照读，无锁；当前读，对读取到的记录加 Record Lock，同时为了确保where条件范围内的数据无变化，会增加Next key lock
- RS，读写均为当前读，不支持快照读。包括select 在内，对读取到的记录加 Record Lock，同时为了确保where条件范围内的数据无变化，会增加Next key lock。

### 死锁

但是在InnoDB中，除单个SQL组成的事务外，锁是逐步获得的，这就决定了InnoDB发生死锁是可能的。

发生死锁后，InnoDB一般都能自动检测到，并使一个事务释放锁并退回，另一个事务获得锁，继续完成事务。但在涉及外部锁，或涉及锁的情况下，InnoDB并不能完全自动检测到死锁，这需要通过设置锁等待超时参数innodb_lock_wait_timeout来解决。需要说明的是，这个参数并不是只用来解决死锁问题，在并发访问比较高的情况下，如果大量事务因无法立即获取所需的锁而挂起，会占用大量计算机资源，造成严重性能问题，甚至拖垮数据库。我们通过**设置合适的锁等待超时阈值**，可以避免这种情况发生。

 下面就通过实例来介绍几种避免死锁的常用方法：

1. 在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序为访问表，这样可以大大降低产生死锁的机会。如果两个session访问两个表的顺序不同，发生死锁的机会就非常高！但如果以相同的顺序来访问，死锁就可能避免。
2. 在程序以批量方式处理数据的时候，如果事先对数据排序，保证每个线程按固定的顺序来处理记录，也可以大大降低死锁的可能。
3. 在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应该先申请共享锁，更新时再申请排他锁，甚至死锁。
4. 在REPEATEABLE-READ隔离级别下，如果两个线程同时对相同条件记录用SELECT...ROR UPDATE加排他锁，在没有符合该记录情况下，两个线程都会加锁成功。程序发现记录尚不存在，就试图插入一条新记录，如果两个线程都这么做，就会出现死锁。这种情况下，将隔离级别改成READ COMMITTED，就可以避免问题。
5. 当隔离级别为READ COMMITED时，如果两个线程都先执行SELECT...FOR UPDATE，判断是否存在符合条件的记录，如果没有，就插入记录。此时，只有一个线程能插入成功，另一个线程会出现锁等待，当第１个线程提交后，第２个线程会因主键重出错，但虽然这个线程出错了，却会获得一个排他锁！这时如果有第３个线程又来申请排他锁，也会出现死锁。对于这种情况，可以直接做插入操作，然后再捕获主键重异常，或者在遇到主键重错误时，总是执行ROLLBACK释放获得的排他锁。

尽管通过上面的设计和优化等措施，可以大减少死锁，但死锁很难完全避免。因此，在程序设计中总是捕获并处理死锁异常是一个很好的编程习惯。

如果出现死锁，可以用SHOW INNODB STATUS命令来确定最后一个死锁产生的原因和改进措施。

## 总结

基本总结：

1. InnoDB的行销是基于索引实现的，如果不通过索引访问数据，InnoDB会使用表锁。
2. InnoDB间隙锁是为了RR级别下避免当前读时可能产生的幻读
3. 在不同的隔离级别下，InnoDB的锁机制和一致性读策略不同。
4. ＭySQL的恢复和复制对InnoDB锁机制和一致性读策略也有较大影响。
5. 锁冲突甚至死锁很难完全避免。

减少锁冲突和死锁机制：

1. 尽量使用较低的隔离级别
2. 精心设计索引，并尽量使用索引访问数据，使加锁更精确，从而减少锁冲突的机会。
3. 选择合理的事务大小，小事务发生锁冲突的几率也更小。
4. 给记录集显示加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁。
5. 不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大减少死锁的机会。
6. 尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响。
7. 不要申请超过实际需要的锁级别；除非必须，查询时不要显示加锁。
8. 对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能。

## 参考

[MySQL · 引擎特性 · InnoDB 事务锁系统简介](http://mysql.taobao.org/monthly/2016/01/01/)

[Innodb中的事务隔离级别和锁的关系](https://tech.meituan.com/innodb_lock.html)

[MySQL锁总结](https://zhuanlan.zhihu.com/p/29150809)

[数据库事务与MySQL事务总结](https://zhuanlan.zhihu.com/p/29166694)

[mysql insert锁机制](http://yeshaoting.cn/article/database/mysql%20insert%E9%94%81%E6%9C%BA%E5%88%B6/)

[通过InnoDB监控状态分析锁占用](http://yeshaoting.cn/article/database/%E9%80%9A%E8%BF%87InnoDB%E7%9B%91%E6%8E%A7%E7%8A%B6%E6%80%81%E5%88%86%E6%9E%90%E9%94%81%E5%8D%A0%E7%94%A8/)

[mysql的并发处理机制_上篇](https://www.cnblogs.com/xinysu/p/7260227.html)

[mysql的并发处理机制_下篇](https://www.cnblogs.com/xinysu/p/7710928.html)