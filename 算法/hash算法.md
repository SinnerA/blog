---
title: hash算法
date: 2018-05-05
tags: 
  - hash
---

## hash

哈希表的插入和查找的平均时间复杂度都为 O(1)，因此在日常工作中使用也较为广泛。

为了保证插入和查找的平均复杂度为 O(1)，hash table 底层一般都是使用数组来实现。对于给定的 key，一般先进行 hash 操作，然后相对哈希表的长度取模，将 key 映射到指定的地方。

```
index = hash(key) % hash_table_size  // index 就是 key 存储位置的索引
```

这里的核心在于如何选取合适的 hash 函数，如果提前知道 key 的一些相关信息，往往可以选取一个不错的 hash 函数。常用的 hash 函数有 SHA-1，SHA-256，SHA-512，这里就不再赘述了。

### 解决冲突

冲突，也叫做碰撞，意思是两个或者多个 key 映射到了哈希表的同一个位置。冲突处理一般有两种方法：开放定址（open addressing）和开链（separate chaining）

- 开放定址

  开放定址的意思是当发生冲突时，我们从当前位置向后按某种策略遍历哈希表。当发现可用的空间的时候，则插入元素。开放地址有一次探测、二次探测和双重哈希。一次探测是指我们的遍历策略是一个线性函数，比如依次遍历冲突位置之后的第 1，2，3…N 位置。如果直接遍历 1，4（=2^2），9 (=3^2)，这就是二次探测的一个例子。双重哈希就是遍历策略间隔由另一个哈希函数来确定。

- 开链

  开链的思想是哈希表中的每个元素都是一个类似链表或者其他数据结构的 head。当出现冲突时，我们就在链表后面添加元素。这也就意味着，如果某一个位置冲突过多的话，插入的时间复杂段将退化为 O(N)。补充一点，如果哈希表的每个元素都是一个链表头的，那么又可以分为头存储元素和不存储元素两种，如下图所示。

简单比较一下这两种处理方法的优劣：开放定址在解决当前冲突的情况下同时可能会导致新的冲突，而开链不会有这种问题。同时开链相比于开放定址局部性较差，在程序运行过程中可能引起操作系统的缺页中断，从而导致系统颠簸。

### rehash

很多语言或者工具包哈希表的内部实现都使用了两个数组，其中一个作为备用。如果当前哈希表的**负载因子**（元素个数/哈希表容量大小）过大或者过小时，就需要将数据切换到备用数组里面，这个过程就是 rehash。新的哈希表的大小可以有很多种方案，比如 redis 里面的哈希表（字典的底层实现）扩展时，新的哈希表的大小为大于当前哈希表里面存放元素的 2 倍的最小的 2 的 n 次幂。

Rehash 过程也很有讲究，这个过程不应该影响当前系统的运行，所以比较推崇的一种方法是**渐进式 rehash**。渐进式 rehash 的主要思想是在 rehash 阶段对于新的写请求，并不会写入老的哈希表里面，而是直接写入到新的哈希表里；对于读请求，优先读取新的哈希表，如果不存在，则去读老的的哈希表同时将这条数据迁移到新的哈希表里面来。

Rehash 有一个问题需要讨论一下：如何鉴定 rehash 阶段的开始与结束？开始很简单，每次写操作或者定期检测一下负载因子，当满足条件则开始 rehash。那么如何鉴定结束呢？一种比较常规的方法是定期检测，但是这涉及到很多问题，比如如何界定检测的时间粒度。另一种是记录下迁移过程。还是以 Redis 为例来说明，Redis 使用的是 1.2 介绍的哈希表元素作为链表头不存储元素的方式，这样数据迁移的时候只需要从原链表将节点删除，然后插入到新的哈希表对应的位置就好了。同时哈希表结构**有一个字段记录了老的哈希表残留的数据**，这样我们只需要检测这个变量（代价很小）就知道 rehash 有没有完成了。rehash 过程如下图所示（来自 《Redis 设计与实现》）

## Bloom Filter

哈希表的问题在于空间利用率不够高。对于某些我们需要排重场景（存储的只有一个 key，不是），比如写爬虫的时候我们需要做网址排重，这个时候使用 Bloom Filter（中文又称作布隆过滤器） 就比较高效。

Bloom filter 的主要思想是使用位图+多个哈希函数。省空间的常用方法就是使用位图；单个哈希函数容易导致冲突，所以采用多个哈希函数。具体方法是预先分配一个大数组用作位图，对于每个 key 的写入，使用多个哈希函数映射到位图上的不同位置。对于 key 的查找，位图上的所有映射位置都为 1 时才表示 key 存在。用伪代码描述如下。

```
var bitmap
func insert(key) {
    for h := range hashs {
        bitmap.setone(h(key))
    }
}

func lookup(key) bool {
    for h := range hashs {
        if bitmap.get(h(key)) != 1 {
            return false
        }
    }
    return true
}

```

下面看一个具体的例子，如下图。插入 x, y, z 分别将多个 hash 函数计算出来的位置 bit 置为 1。这时候集合包含了三个元素 {x, y, z}，此时要查找 w，通过 hash 函数计算出来的位置如下图所示，由于有一个 bit 不是 1，所以可以确定 w 不再集合里面。

[![img](https://upload.wikimedia.org/wikipedia/commons/a/ac/Bloom_filter.svg)](https://upload.wikimedia.org/wikipedia/commons/a/ac/Bloom_filter.svg)

上面只说到了插入和查找，那么删除呢？bloom filter 是不支持删除的。除此之后 bloom filter 对于不存在的 key 的查找是存在误判率的，但是这个概率对于大部分使用场景来说都是可接受的。关于误判率的具体推算可以参考其他资料，比如 wikipedia，这里就不细说了。

## 一致hash



## 分布式哈希表（DHT）



## 参考

[聊一聊哈希表](http://legendtkl.com/2017/07/23/about-hash-table/)

[大数据处理-Bitmap](http://www.cnblogs.com/yangjiannr/p/da-shu-ju-chu-libitmap.html)

[Bloom Filter – wikipedia](https://en.wikipedia.org/wiki/Bloom_filter)