---
title: Linux基本概念
date: 2017-10-14
tags: Basic
---

## 历史

### Linux起源

**Linux 的源头要追溯到最古老的UNIX。**

1969年，**Bell实验室**的Ken Thompson开始利用一台闲置的 PDP-7计算机开发了一种多用户，多任务操作系统。很快，Dennis Richie加入了这个项目，在他们共同努力下诞生了最早的UNIX。Richie受一个更早的项目——MULTICS的启发，将此操作系统命名为 Unix。早期UNIX是用汇编语言编写的，但其第三个版本用一种崭新的编程语言C重新设计了。C是Richie设计出来并用于编写操作系统的程序语言。 通过这次重新编写，Unix得以移植到更为强大的 DEC PDP-11/45与11/70计算机上运行。后来发生的一切，正如他们所说，已经成为历史。Unix从实验室走出来并成为了操作系统的主流，现在几乎每个主要的计算机厂商都有其自有版本的Unix.

<!-- more -->

Linux起源于一个学生的简单需求。**Linus Torvalds**——Linux的作者与主要维护者，在其上大学时所买得起的唯一软件是Minix。 Minix是一个类似Unix，被广泛用来辅助教学的简单操作系统。Linus 对Minix不是很满意，于是决定自己编写软件。他以学生时代熟悉的**Unix作为原型**， 在一台Intel 386 PC上开始了他的工作。他的进展很快，受工作成绩的鼓舞，他将这项成果通过互连网与其他同学共享，主要用于学术领域。有人看到了这个软件并开始分发。每当出现新问题时，有人会立刻找到解决办法并加入其中，很快的， Linux成为了一个操作系统。值得注意的是Linux并没有包括Unix源码。**它是按照公开的POSIX标准重新编写的。**Linux大量使用了由麻省剑桥自由软件基金的GNU软件，同时Linux自身也是用它们构造而成。

后来，Unix这个名字成为了商标，只有花钱进行POSIX标准兼容性测试并通过了的OS，才能称为Unix，其余的OS，最多称为Unix-like OS或者*nix OS。

### GNU协议

GNU是“GNU is Not Unix”的递归缩写。

Richard Stallman为了维护软件的自由流通，于1985年发表了著名的**GNU宣言**(GNU Manifesto)，正式宣布要开始进行一项宏伟的计划：创造一套完全自由免费，兼容于Unix的**操作系统GNU**（GNU's Not Unix!）。之后他又建立了自由软件基金会来协助该计划。

他于1989年与一群律师起草了广为使用的**GNU通用公共协议证书**（GNU General Public License, GNU GPL），创造性地提出了“反版权”（或“版权属左”，或“开权”，copyleft）的概念。 同时，GNU计划中除了最关键的Hurd操作系统内核之外，其他绝大多数软件已经完成。

1991年芬兰大学生Linus Torvalds在GPL条例下发布他自己创作的Linux操作系统内核，至此GNU计划正式完成，操作系统被命名为**GNU/Linux**（或简称Linux）。

GNU 包含3个协议条款，

- GPL: GNU通用公共许可证(GNU General Public License）
- LGPL: GNU较宽松公共许可证(GNU Lesser General Public License), 旧称 GNU Library General Public License (GNU 库通用公共许可证)
- GFDL: GNU自由文档许可证(GNU Free Documentation License)的缩写形式。

>其他常见协议还包括：
>
>- BSD(Berkeley Software Distribution): 伯克利软件分发许可协议
>- MIT(Massachusetts Institute of Technology): MIT许可协议之名源自麻省理工学院，又称“X许可协议”或“X11许可协议” 
>- Apache(Apache License): Apache许可协议  
>- MPL(Mozilla Public License): Mozilla公共许可协议
>
>

### GCC编译器

GCC（GNU C Compiler）是GNU推出的功能强大、性能优越的多平台编译器，是GNU的代表作品之一。

GCC原本作为GNU操作系统的官方编译器，**现已被大多数类Unix操作系统（如Linux、BSD、Mac OS X等）采纳为标准的编译器**，GCC同样适用于微软的Windows。

GCC 原名为 GNU C 语言编译器（GNU C Compiler），因为它原本只能处理 C语言。GCC 很快地扩展，变得可处理 C++。后来又扩展能够支持更多编程语言，如Fortran、Pascal、Objective-C、Java、Ada、Go以及各类处理器架构上的汇编语言等，所以改名GNU编译器套件（GNU Compiler Collection）。

### POSIX标准

POSIX(Portable Operation System Interface )代表 “可移植操作系统接口” 。

主要是UNIX系统早期发展得太快，以System V(AT&T)为首的建制派和BSD(伯克利)为首的学院派各自搞了很多新玩意儿，相互之间竞争和不兼容之处越来越多，各个商业厂家也首鼠两端，无所适从。于是就有好事者(**IEEE**)出来一统江湖，把各个山头叫来坐下来谈，统一一下各家的乱七八糟，提出一个各方都能接受和支持的标准API，基本就是糅合一下SYSV和BSD。**只要按照这个API标准写程序，理论上就可以在各个操作系统和硬件平台上编译运行。**

Linux作为一个从头开始研制的新操作系统，逐渐发展起来以后为了尽可能获得大量应用软件支持，也明智地选择了用POSIX作为API设计的标准。

> 尾巴上**X**表明其对Unix API的传承

## Linux与Unix的区别

Linux和UNIX的**最大的区别**是，前者是开发源代码的**自由软件**，而后者是对源代码实行知识产权保护的传统**商业软件**。

## 内存管理

### 用户空间和内核空间

现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。

针对linux操作系统而言，通常将**最高的1G字节**（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。

## 进程管理

### 进程切换

为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。

从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：
1. 保存处理机上下文，包括程序计数器和其他寄存器。
2. 更新PCB信息。
3. 把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。
4. 选择另一个进程执行，并更新其PCB。
5. 更新内存管理的数据结构。
6. 恢复处理机上下文。

## 文件管理

### 文件描述符fd

文件描述符（file descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。

文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。

## IO管理

### 缓存I/O

缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，**数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间**。

**缓存 I/O 的缺点：**
数据在传输过程中需要在应用程序地址空间和内核进行**多次数据拷贝**操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。
