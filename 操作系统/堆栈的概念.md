---
title: 堆栈的概念
date: 2017-10-05
tags:
---

堆是堆（heap），栈是栈（stack），堆栈是栈。不喜欢“堆栈”这种叫法，容易产生误解。堆栈都是一种数据结构，这里主要讨论计算机内存中的堆栈概念。

<!-- more -->

### 运行时的数据结构

代码源文件，经过预处理，编译，汇编，链接之后，得到ELF(Executable and Linkable Format)文件，也就是可执行文件。 其具体内容参考图1：

> 段：这里表示UNIX中一个二进制文件相关的内容块，而不是Intel x86内存模型中地址空间的段。
>
> BSS：“Block Started by Symbol（“由符号开始的块”）”的缩写，是Unix链接器产生的未初始化数据段。

![img](http://img.my.csdn.net/uploads/201203/22/0_1332382865SXjE.gif)

​							图1 C语句的各个部分会出现在哪些段中

<!-- more -->

为什么要以段的形式组织，因为段可以方便地映射到链接器在运行时可以直接载入的对象中。链接器直接将文件拷贝到内存中（一般使用mmap()系统调用），段在正在执行的程序中是一个内存区域，每个区域都有特定的目的，如图2所示。

![“可执行文件中的段在内存中如何布局”的图片搜索结果](http://hi.csdn.net/attachment/201109/22/0_131665857077L7.gif)

​								图2 可执行文件中的段在内存中如何布局

图2显示了一个即将执行的程序的内存布局。

我们仍然需要一些内存空间，用于保存局部变量、临时变量、传递到函数中的参数等。栈段（stack segment）就是用于这个目的。

我们还需要堆（heap）空间，用于动态分配内存。

考虑到共享库时，进程的地址空间如图3所示。

![img](http://images2015.cnblogs.com/blog/477638/201512/477638-20151208133114293-1927882385.png)

​								    图3 一个Linux进程的虚拟存储器

### Stack

栈段（stack）的实现与数据结构中的栈是一致的，符合FIFO特性。不过系统的设计者采用了一种稍微灵活一些的方法，可以stack从顶部增加或删除值，也支持修改位于stack中间的值。

运行时系统维护了一个指针（位于寄存器中），通常称为sp，用于提示stack当前的顶部位置。

stack段主要有3个用途，其中两个跟函数有关，另一个跟表达式计算有关。

1. 为函数内部声明的局部变量提供存储空间
2. 进行函数调用时，stack存储与此有关的一些维护性信息。这些信息被称为栈结构（stack frame），更常用的名字是过程活动记录（preceddure activition recored）,它包括函数调用地址（当所调用的函数结束后调回的地方），任何不适合装入寄存器的参数以及一些寄存器值得保存，如图4所示
3. stack也被用作临时存储区，存储一些计算过程中产生的临时值。比如计算一个很长的算术表达式，可以把部分计算结果压入到stack中，需要时再取出。

除了递归调用之外，stack并非必需。因为在编译时可以知道局部变量、参数和返回地址所需空间的固定大小，并可以将他们分配于BSS段。

![img](http://img.blog.csdn.net/20160429100107048)

​							图4 每个函数调用在运行时创建过程活动记录

###Heap

heap区域用于动态分配的存储，也就是通过malloc（内存分配）函数获得的内存，并通过指针访问。heap中的东西是匿名的，不能按名字访问，只能通过指针访问。

从heap获取内存的唯一办法就是通过调用malloc（以及同类的calloc、realloc等）库函数。

heap中的



[程序的编译链接过程](http://www.cnblogs.com/kekec/p/3238741.html)
