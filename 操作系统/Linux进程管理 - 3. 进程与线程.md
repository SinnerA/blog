---
title: Linux进程管理 - 3. 进程与线程
date: 2018-05-19
tags: 
    - Linux
    - 进程
---

[TOC]

## 线程的由来

早期是单道程序，独自在运行，后来有了多道程序，就是在计算机内存中同时存放几道互相独立的程序，他们相互交替运行，宏观上是并行的。

引入进程的目的，是为了多道程序能并发执行，而引入线程，则是**为了减少并发执行时的所付出的开销，提高并发性能**。进程下面的线程共享了进程的某些资源，担有自己独立的运行栈。

进程所维护的是程序所包含的资源(静态资源)，如：

1. 地址空间（用户态进程栈）
2. 打开的文件
3. 文件系统状态
4. 信号处理handler等;

线程所维护的运行相关的资源(动态资源), 如: 

1. 运行栈（**进程的堆上分配的**）
2. 调度相关的控制信息
3. 待处理的信号集等;

一直以来，linux内核并没有线程的概念。每一个执行实体都是一个task_struct结构。为了模拟线程，通过系统调用clone创建子进程时, 可以有选择性地让子进程共享父进程所引用的资源，这样的子进程通常称为轻量级进程，也就是线程。

linux上的线程就是基于轻量级进程, 由用户态的pthread库实现的，使用pthread以后，在用户看来，每一个task_struct就对应一个线程，而一组线程以及它们所共同引用的一组资源就是一个进程。

但是，一组线程并不仅仅是引用同一组资源就够了，它们还必须被视为一个整体。

POSIX标准对线程的定义：

1. 查看进程列表的时候, 相关的一组task_struct应当被展现为列表中的一个节点;
2. 发送给这个”进程”的信号(对应kill系统调用), 将被对应的这一组task_struct所共享, 并且被其中的任意一个”线程”处理;
3. 发送给某个”线程”的信号(对应pthread_kill), 将只被对应的一个task_struct接收, 并且由它自己来处理;
4. 当”进程”被停止或继续时(对应SIGSTOP/SIGCONT信号), 对应的这一组task_struct状态将改变;
5. 当”进程”收到一个致命信号(比如由于段错误收到SIGSEGV信号), 对应的这一组task_struct将全部退出;
6. 等等(以上可能不够全);

### 线程与进程的区别

多进程缺点：

1. **创建消耗大**。fork一个子进程的消耗是很大的，fork是一个昂贵的系统调用，即使使用写时复制(copy-on-write)技术。
2. **通信复杂**。各个进程拥有自己独立的地址空间，进程间的协作需要复杂的IPC技术，如消息传递和共享内存等。

在操作系统设计上，从进程演化出线程，最主要的目的就是更好的支持SMP以及减小（进程/线程）上下文切换开销。

 区别：

1. 资源：

   - 独有：线程有自己的执行栈，寄存器集合（切换上下文），只读数据区等
   - 共享：堆，用户态进程栈，文件资源，页表（虚拟空间）

2. 上下文切换：

   - 进程：保存页表，文件资源，寄存器，控制信息等
   - 线程：线程id，寄存器，运行栈

3. 创建：创建线程比创建进程更加低消耗，因为创建线程不需要复制资源。

4. 通信：

   进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程**同步和互斥**手段的辅助，以保证数据的一致性。

## Linux线程的实现

### linux threads

在linux 2.6以前，pthread线程库对应的实现是一个名叫linuxthreads的lib。

linuxthreads利用前面提到的轻量级进程来实现线程，但是对于POSIX提出的那些要求，linuxthreads除了第5点以外，都没有实现

### NPTL

到了linux 2.6，glibc中有了一种新的pthread线程库–NPTL(Native POSIX Threading Library)。NPTL实现了前面提到的POSIX的全部5点要求。但是，实际上与其说是NPTL实现了，不如说是linux内核实现了。

在linux 2.6中，内核有了线程组的概念，task_struct结构中增加了一个tgid(thread group id)字段。如果这个task是一个”主线程”，则它的tgid等于pid，否则tgid等于进程的pid(即主线程的pid)。

这里实现的模型是1:1的

### NGPT

说到这里, 也顺便提一下NGPT(Next Generation POSIX Threads)。

上面提到的两种线程库使用的都是内核级线程(每个线程都对应内核中的一个调度实体)。这种模型称为1:1模型(1个线程对应1个内核级线程)；而NGPT则打算实现M:N模型(M个线程对应N个内核级线程)，也就是说若干个线程可能是在同一个执行实体上实现的。线程库需要在一个内核提供的执行实体上抽象出若干个执行实体, 并实现它们之间的调度。这样被抽象出来的执行实体称为用户级线程。

这个项目后来已经放弃了，只剩下维护。

### 现状

大部分现代 Linux 发行版都预装了 LinuxThreads 和 NPTL，因此它们提供了一种机制来在二者之间进行切换。要查看您的系统上正在使用的是哪个线程库，请运行下面的命令：

`$ getconf GNU_LIBPTHREAD_VERSION`

这会产生类似于下面的输出结果：

`NPTL 0.34`或者：`linuxthreads-0.10`

## 内核线程与用户线程

内核线程也叫做守护线程，主要在后台做一些周期性同步，记录日志之类的事情。

内核线程是由内核自身生成的，也就是说不是通过clone生成的，但其实底层还是由do_fork生成的，和普通用户线程相比：

共同点

1. 都由do_fork()创建，每个线程都有独立的task_struct和内核栈
2. 都参与调度，内核线程也有优先级，会被调度器平等地换入换出

不同点：

1. 内核线程只工作在内核态中；而用户线程则既可以运行在内核态（执行系统调用时），也可以运行在用户态；
2. 内核线程没有用户空间，所以对于一个内核线程来说，它的0~3G的内存空间是空白的，它的current->mm是空的，与内核使用同一张页表；而用户线程则可以看到完整的0~4G内存空间。

### 映射关系

注意：很多名词概念很容易混淆，一般在提到内核线程与用户线程的映射对应关系时，内核线程指的就是内核调度实体，能够被CPU执行的实体。简单来说，就是能够运行在内核空间的就是内核线程。

映射关系：其实并不存在内核线程与用户线程这样**两个线程实体**一一对应，这种说法只是一个虚拟的概念。比如：对于1:1模型中，如果有3个用户线程，那么并不存在真正的3个内核线程与其对应，只是在运行时，还是这3个用户线程变成了3个内核线程，也是1对1的关系。然而对于n:1的模型，只有一个用户线程会陷入内核态，变成内核线程，也就是n对1的关系。

轻量级线程（LWP）在Linux中指的就是clone出来的进程，用它支持了多线程。

#### 1:1

一对一模型中，每个用户线程都对应各自的内核调度实体。

线程的每次操作会在**用户态和内核态切换**，线程切换花销大。另外，内核为每个线程都映射调度实体，如果系统出现大量线程，会对系统性能有影响。

实现简单，LinuxThread与NPTL都是采用这种模型。

![LWP.JPG](https://github.com/SinnerA/blog/tree/master/illustrations/LWP.png)

#### n:1

只存在一个内核调度实体。

线程的创建、调度、同步的所有细节**全部由进程的用户空间线程库来处理**。用户态线程的很多操作对内核来说都是透明的，因为不需要内核来接管，这意味不需要内核态和用户态频繁切换。

当多线程并发执行时，如果其中一个线程执行IO操作时，内核接管这个操作，如果IO阻塞，用户态的其他线程都会被阻塞，因为这些线程都对应同一个内核调度实体。

![Uthread1.JPG](https://github.com/SinnerA/blog/tree/master/illustrations/Uthread1.png)

#### m:n

集合了上面两种的优点，用户态管理线程，又不会因为某个线程阻塞导致所有线程阻塞。

实现复杂。NGPT使用的就是这种方式，后来已经放弃。

## 参考

1. [POSIX Threads](https://en.wikipedia.org/wiki/POSIX_Threads)Wikipedia上基本概念的介绍
2. [The Native POSIX Thread Library for Linux](http://people.redhat.com/drepper/nptl-design.pdf)介绍了设计 NPTL 的原因和目标，其中包括了 LinuxThreads 的缺点和 NPTL 的优点。 [LinuxThreads FAQ](http://pauillac.inria.fr/~xleroy/linuxthreads/faq.html) 包含了有关 LinuxThreads 和 NPTL 的常见问题。
3. [linux线程浅析](http://blog.csdn.net/ctthuangcheng/article/details/8914712)
4. [Linux 线程模型的比较：LinuxThreads 和 NPTL](https://www.ibm.com/developerworks/cn/linux/l-threading.html)
