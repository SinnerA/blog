---
title: 
date: 2018-05-20
tags: Linux 进程
---

[TOC]

## 创建

### 进程四要素

1. 有一段程序供其执行
2. 有自己的专用系统堆栈空间（私有财产）
3. 有进程控制块（task_struct）（“有身份证，PID”）
4. 有独立的存储空间

缺了第四点的，是线程，如果完全没有用户空间称为内核线程，共享用户空间的称为用户线程。

### fork，vfork，clone

Unix标准的复制进程的系统调用时fork（即分叉），但是Linux，BSD等操作系统并不止实现这一个，确切的说linux实现了三个，fork,vfork,clone（确切说vfork创造出来的是轻量级进程，也叫线程，是共享资源的进程）

| 系统调用 | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| fork     | fork创造的子进程是父进程的**完整副本**，复制了父亲进程的资源，包括内存的内容task_struct内容 |
| vfork    | vfork创建的子进程与父进程**共享数据段**，而且由vfork()创建的子进程将先于父进程运行 |
| clone    | Linux上创建线程一般使用的是pthread库，实际上linux也给我们提供了创建线程的系统调用，就是clone |

不同的体系结构可能采用不同的方式或者不同的寄存器来传递参数，而上面函数的任务就是从处理器的寄存器中提取用户空间提供的信息, 并调用体系结构无关的**_do_fork（或者早期的do_fork）函数, 负责进程的复制**

#### fork

fork 创造的子进程复制了父亲进程的资源（写时复制技术），包括内存的内容task_struct内容（2个进程的pid不同）。这里是资源的复制不是指针的复制。

子进程一般被创建后，马上需要执行自己的程序，如果每次都copy父进程的内存，则每次执行的时候又要被替换掉，多了很多无效数据的复制，很低效，因此fork时采用写时复制复制技术。

 fork子进程时完全复制父进程的栈空间，也复制了页表，但没有复制物理页面，所以这时虚拟地址相同，物理地址也相同（逻辑上是独立的，物理上共享）。一直到，其中一个进程要进行写操作，这时才发生物理页面的复制。

**写时复制技术**（Copy-On-Write）：简单来说，写的时候再复制，lazy模式。IO中也用到了这个思想，先写入缓存，关闭文件时才写入磁盘。

![img](https://github.com/SinnerA/blog/tree/master/illustrations/cow.png)

#### vfork

vfork是一个过时的应用，vfork也是创建一个子进程，但是子进程共享父进程的空间。在vfork创建子进程之后，父进程阻塞，直到子进程执行了exec()或者exit()。

vfork最初是因为fork没有实现COW机制，而很多情况下fork之后会紧接着exec，而exec的执行相当于之前fork复制的空间全部变成了无用功，所以设计了vfork。而现在fork使用了COW机制，唯一的代价仅仅是复制父进程页表的代价，所以vfork不应该出现在新的代码之中。

注：vfork时，子进程与父进程共享虚拟空间，自然也是共享物理页面的，因此逻辑上和物理上都是共享的

#### clone

clone是Linux为创建**线程**设计的（虽然也可以用clone创建进程）。所以可以说clone是fork的升级版本，不仅可以创建进程或者线程，还可以指定创建新的命名空间（namespace）、有选择的继承父进程的内存、甚至可以将创建出来的进程变成父进程的兄弟进程等等。

clone可以让你有选择性的继承父进程的资源，你可以选择想vfork一样和父进程共享一个虚拟空间，从而使创造的是线程。

#### clone和fork的区别

1. clone和fork的调用方式很不相同，clone调用需要传入一个函数，该函数在子进程中执行
2. clone和fork最大不同在于clone不再复制父进程的栈空间，而是自己**创建一个新的。**共享父进程的虚拟空间，自己又有独立栈。

### 进程创建

1. fork时拷贝当前进程创建子进程（写时复制COW）
2. fork的实际开销是复制父进程页表，以及给子进程创建唯一的进程描述符
3. exec：载入可执行文件到进程地址空间并运行
4. fork过程：
   1.  为子进程创建内核栈thread_info和task_struct
   2. 将进程设置为`TASK_RUNNING`态，初始化调度策略等，并分配到特定cpu上
   3. 分配pid
   4. 最后返回到`do_fork()`，将新进程激活(加入task队列)

### 线程创建

注意：

- 内核没有线程的概念，线程被视为与其它进程**共享资源的进程**，作为进程间共享资源的手段
- 线程共享进程地址空间，支持多处理器上的并发

#### 用户线程

对内核来说，用户空间创建线程就是通过clone调用在创建进程时指定共享资源

CLONE标志

- `CLONE_FILES`：共享打开文件
- `CLONE_FS`：共享文件系统信息
- `CLONE_SIGHAND`：共享信号处理和pending信号
- `CLONE_VM`：共享地址空间
- `CLONE_VFORK`：vfork时父进程睡眠等待子进程唤醒

#### 内核线程

内核线程都是从kthreadd进程创建

内核线程与普通线程

- 没有独立的地址空间，mm指针被设为NULL
- 只在内核空间运行
- 和普通进程一样可以被抢占和调度
- 主要完成一些内核任务，如flush、ksoftirq

## 退出

1. 内核通过`do_exit()`执行进程退出过程
   - 释放进程地址空间mm_struct
   - 删除进程建立的共享内存（其实只是设置为不可用，系统后面会进行回收）
   - 递减文件描述符和文件系统数据的引用计数
   - 通知自身线程执行退出
   - 向父进程发信号，给子进程寻找养父，找不到则指定为init进程，并设置退出状态为`EXIT_ZOMBIE`
   - 最后调用schedule()切换到新进程，当前进程不再被调度
   - 最后进程退出时，退出状态处于`EXIT_ZOMBIE`，占用内核栈、`thread_info`和`task_struct`结构，等待父进程检索到进程信息，执行最后的清理工作
2. 最后的清理工作——wait()
   - 进程exit后，进程描述符还保留，等待父进程执行wait系统调用进行回收
   - wait对应的系统调用，都是通过`do_wait()`来执行清理过程
   - `do_wait()`中遍历每个子进程，最终对`EXIT_ZOMBIE`态的进行进行回收
   - `wait_task_zombie()`中回收子进程PID，然后调用`release_task()`执行最终的退出过程
3. 孤儿进程的处理
   - 前面讲到，`do_exit()`调用`exit_notify()`来执行寻找父进程的过程
   - `exit_notify()`首先调用`forget_original_parent()`,最终通过`find_new_reaper()`来寻找可能的

## 过程图

![process_life_cycle](https://github.com/SinnerA/blog/tree/master/illustrations/process_life_cycle.png)

## 参考

[Linux内核初探 之 进程(二) —— 进程管理](https://dupengair.github.io/2016/10/25/linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E7%A1%80%E7%AF%87-Linux%E5%86%85%E6%A0%B8%E5%88%9D%E6%8E%A2-%E4%B9%8B-%E8%BF%9B%E7%A8%8B-%E4%BA%8C-%E2%80%94%E2%80%94-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/)

[fork()、vfork()、clone()的区别](https://blog.csdn.net/gogokongyin/article/details/51178257)
