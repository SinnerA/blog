---
title: 深入探索进程，线程，协程
date: 2017-10-06
tags: 
  - OS
  - Basics
---

### 进程与线程

#### 概念

以下内容来自[知乎网友的回答](https://www.zhihu.com/question/25532384/answer/81152571)

> 首先来一句概括的总论：**进程和线程都是一个时间段的描述，是CPU工作时间段的描述。**
>
> <!-- more -->
>
> **下面细说背景**：
> CPU+RAM+各种资源（比如显卡，光驱，键盘，GPS, 等等外设）构成我们的电脑，但是电脑的运行，实际就是CPU和相关寄存器以及RAM之间的事情。
>
> **一个最最基础的事实**：CPU太快，太快，太快了，寄存器仅仅能够追的上他的脚步，RAM和别的挂在各总线上的设备完全是望其项背。那当多个任务要执行的时候怎么办呢？轮流着来?或者谁优先级高谁来？不管怎么样的策略，一句话就是在CPU看来就是轮流着来。
>
> **一个必须知道的事实**：执行一段程序代码，实现一个功能的过程介绍 ，当得到CPU的时候，相关的资源必须也已经就位，就是显卡啊，GPS啊什么的必须就位，然后CPU开始执行。这里除了CPU以外所有的就构成了这个程序的执行环境，也就是我们所定义的程序上下文。当这个程序执行完了，或者分配给他的CPU执行时间用完了，那它就要被切换出去，等待下一次CPU的临幸。在被切换出去的最后一步工作就是保存程序上下文，因为这个是下次他被CPU临幸的运行环境，必须保存。
>
> **串联起来的事实**
>
> 先加载程序A的上下文，然后开始执行A，保存程序A的上下文，调入下一个要执行的程序B的程序上下文，然后开始执行B,保存程序B的上下文*。。。*。
>
> **========= 重要的东西出现了========**
>
> 就是这样的背景出来的，**两个名词不过是对应的CPU时间段的描述，名词就是这样的功能。**
>
> - **进程就是包换上下文切换的程序执行时间总和** = **CPU加载上下文+CPU执行+CPU保存上下文**
>
> **线程是什么呢？**
>
> 进程的颗粒度太大，每次都要有上下的调入，保存，调出。如果我们把进程比喻为一个运行在电脑上的软件，那么一个软件的执行不可能是一条逻辑执行的，必定有多个分支和多个程序段，就好比要实现程序A，实际分成 a，b，c等多个块组合而成。那么这里具体的执行就可能变成：
>
> 程序A得到CPU =》CPU加载上下文，开始执行程序A的a小段，然后执行A的b小段，然后再执行A的c小段，最后CPU保存A的上下文。
>
> 这里a，b，c的执行是共享了A的上下文，CPU在执行的时候没有进行上下文切换的。这里的**a，b，c就是线程，也就是说线程是共享了进程的上下文环境，的更为细小的CPU时间段。**
>
> **到此全文结束，再一个总结：**
>
> **进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同。**

书上和网上看过很多对进程线程的描述，这个是我认为最为通俗易懂的。

<!-- more -->

**资源重复浪费**（代码，数据，文件，寄存器，栈）

**进程上下文切换代价大**

进程上下文切换：

- task_struct，好几层的链表结构



共享代码，共享数据，共享打开文件，其他若干资源，则适合 “线程”

线程： 属于一个任务（task），自身资源：寄存器，栈（局部变量，函数返回值）

线程好处：

- 有效表达线索，利于跟踪，有自己的program context
- 响应快（e.g. web应用前端）
- 上述提到两点：资源共享（切换代价小），节省公共资源
- 反应了硬件的特性，利用多核，实现并行，共享cache



**带来的现实问题**

调度：PCB -> TCB

调度队列中，可能混合着PCB，TCB，意味着操作系统要重写，Windows在90年代才出现，所以支持了线程，但是Linux在70年代就出现了，开始时间周期长意味着不可能重写。

**用户级**

于是，由于无法更改内核，又要实现线程，Linux自己模拟一套线程（用户级线程），也就是一些库函数（POSIX pthreads）。CPU有mod_bit状态位，用于区分内核态，用户态，杜绝了黑客攻击操作系统。

- Java threads（JVM在用户态，支持了线程），如果操作系统直接支持了线程，JVM可以直接调用内核态线程

  > 大部分JVM实例运行在宿主操作系统上，java线程API通常采用宿主上的线程库来实现，也就意味着，在Unix和Linux中通常采用Pthread，而在Windows上采用Win32 API来实现

- POSIX pthreads

- Win32 threads

**内核级**

- Windows XP/2000
- Solaris

意味着，线程和进程对于操作系统来说没有区别

**多线程模型**

用户级和内核级必要要对应起来

- 一对一

  如果OS支持线程，那么内核里面就有TCB，一个TCB对应一个用户级线程，用户使用线程时，直接对内核线程进行调度。

- 多对一

  如果OS不支持线程，内核里面只有PCB，也想要使用线程。CPU时间分配，先分配给API库函数（用户态），库函数再去分配到各个用户态线程，有一个二次分配的过程。

  对于Solaris OS中，API库函数中又设计了轻量级线程（LWP），这就涉及到具体实现了，各个OS实现不同。

  局限性：

  - 二次分配，效率低
  - 程序出错，则PCB被掉离开，其他对应在这个PCB上的线程都无法执行
  - 因此，如果OS支持线程，则建议使用“一对一”

- 多对多

  如果OS不支持线程，还能有“多对多”模型。

  好处：用户线程得到CPU资源的可能性增大

  用户创建线程时，可以指定“多对一“或者”多对多“

- two-level

  既提供”一对一“，也提供”多对多“（可以退化为”多对一“），因此支持了以上3种类型，实现上很复杂。

  如：Solaris 8 and earlier，HP-UX，IRIX





**线程管理相对于进程管理，带来的新问题**：

- fork()操作和exec()操作语义有变化

  fork：fork之后是fork本线程，还是该进程内所有线程？都行

  exec：加载一个新的可执行文件，替换原来进程的代码段，数据段，以及堆栈，但是这些代码段和数据段又是所有线程共享的，这么做有影响吗？都行

- 撤销线程

  撤销时，撤销共享资源吗？两种方案：

  - 异步撤销：立即撤销
  - 延后撤销：定期检查共享资源能否撤销，即是否还是使用，如果没有就可以撤销

- Signal handling

  Unix中进程间的暗语发送，如何相应？一个线程还是所有线程响应？


- Thread pools

  申请TCB，malloc（慢），或者页面申请（浪费），初始化提前做好，放在池子里

- Thread specific data

  ​

- Scheduler activations

  ​





####联系



####用户线程，内核线程



#### 注意事项



### 协程

#### 概念

