---
title: Linux内存管理 - 1.概览
date: 2018-05-24
tags: Linux内核 内存管理
---

[TOC]

## Linux内存模型

下图给出了硬件、系统、进程三个层面的内存之间的概要关系。

![Linux内存体系](/Users/sinnera/sinnera.github.io/source/illustrations/linux_memory_01.png)

### 硬件角度

从硬件上看，Linux系统的内存空间由两个部分构成：**物理内存和SWAP（位于磁盘）**。物理内存是Linux活动时使用的主要内存区域；当物理内存不够使用时，Linux会把一部分暂时不用的内存数据放到磁盘上的SWAP中去，以便腾出更多的可用内存空间；而当需要使用位于SWAP的数据时，必须先将其换回到内存中。

### Linux角度

#### 内核空间和用户空间

为了保证用户进程不能直接操作内核，保证内核的安全，操心系统将虚拟空间划分为两部分：内核空间（Kernel space）、用户空间（User space）。
内核内存是Linux自身使用的内存空间，主要提供给程序调度、内存分配、连接硬件资源等程序逻辑使用。

用户内存是提供给各个进程主要空间，Linux给各个进程提供相同的虚拟内存空间；这使得进程之间相互独立，互不干扰。实现的方法是采用虚拟内存技术：给每一个进程一定虚拟内存空间，而只有当虚拟内存实际被使用时，才分配物理内存。如下图所示，对于32的Linux系统来说，一般将0～3G的虚拟内存空间分配做为用户空间，将3～4G的虚拟内存空间分配为内核空间；64位系统的划分情况是类似的。

区别：

- 内核空间可以访问所有的CPU指令和所有的内存空间、I/O空间。
- 用户空间只能访问有限的资源，若需要特殊权限，可以通过系统调陷入内核态，从而可以访问内核空间
- 所有内核进（线）程共用一个地址空间，而用户进程都有各自的地址空间。

![Linux内核内存与用户内存空间](/Users/sinnera/sinnera.github.io/source/illustrations/linux_memory_02.png)

### 进程角度

#### 用户态进程栈

从进程的角度来看，进程能直接访问的用户内存（虚拟内存空间）被划分为5个部分：文本段、数据段、BSS、堆、栈、未使用区。

文本段（.text）：已编译的机器代码，运行过程中不能被修改，具有只读和固定大小的特点。

数据段（.data）：全局数据，静态数据和一些常量字符串等，其大小也是固定的。

BSS（.bss）：未初始化的全局和静态变量，以及所有被初始化为 0 的全局或者静态变量。在目标文件中这个节不占据实际的空间，它仅仅是一个占位符。

堆：是运行时动态申请的空间，属于运行时直接申请、释放的内存资源。

栈：用来存放函数的传入参数、临时变量，以及返回地址等数据。

未使用区：分配新内存空间的预备区域。

![img](/Users/sinnera/sinnera.github.io/source/illustrations/linux_memory_03.png)

![img](/Users/sinnera/sinnera.github.io/source/illustrations/linux_memory_04.png)

#### 内核态和用户态

（1）**当一个任务（进程）执行系统调用而陷入内核代码中执行时，称进程处于内核运行态（内核态）。**此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。

（2）**当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）**。此时处理器在特权级最低的（3级）用户代码中运行。当正在执行用户程序而突然被中断程序中断时，此时用户程序也可以象征性地称为处于进程的内核态。因为中断处理程序将使用当前进程的内核栈。

在内核态申请内存比在用户态申请内存要更为直接，它没有采用用户态那种延迟分配内存技术。内核认为一旦有内核函数申请内存，那么就必须立刻满足该申请内存的请求，并且这个请求一定是正确合理的。相反，对于用户态申请内存的请求，内核总是尽量延后分配物理内存，用户进程总是先获得一个虚拟内存区的使用权，最终通过缺页异常获得一块真正的物理内存。

## 内核空间

### 内核映射

Linux系统对自身进行了划分，一部分核心软件独立于普通应用程序，运行在较高的特权级别上，它们驻留在被保护的内存空间上，拥有访问硬件设备的所有权限，Linux将此称为内核空间。将用户控件和内核空间置于这种非对称访问机制下有很好的安全性。当然用户进程通过系统调用陷入内核态，也能访问内核空间。

内核空间虚拟地址是所有进程共享的，重要的是，从效率角度看， 如果需要查页表的话，速度太慢；于是，内核在初始化时，就创建内核空间的映射（因为所有进程共享，有一份就够了），并且，采用的就是线性映射，而不是走页表翻译这种类似哈希表的方式。

但是，不能内核空间不能完全用来线性映射，因为这样内核空间只能访问到1G的物理内存，所以前面896M做线性映射，剩余了128M（高端内存）用于做动态映射，这样才能访问到整个物理内存。

![img](/Users/sinnera/sinnera.github.io/source/illustrations/linux_memory_space.png)

注：对于64位系统，将拥有16TB的虚拟空间，内核将512G划分为内核空间，如果物理内存小于512G的话，则不存在高端内存，因为只需要线性映射，内核空间就能访问到所有物理内存；物理内存大于512G的话，也需要高端内存做动态映射。

### 高端内存

#### 由来

当内核模块代码或线程访问内存时，代码中的内存地址都为逻辑地址，而对应到真正的物理内存地址，需要地址**一对一**的映射。

假设按照上述简单的地址映射关系，若机器中安装8G物理内存，那么内核就只能访问前1G物理内存，后面7G物理内存将会无法访问。即使安装了8G物理内存，那么后面7G的内存，内核该怎么去访问呢？

显然不能将内核地址空间全部用来简单的地址映射。因此x86架构中将内核地址空间划分三部分：ZONE_DMA、ZONE_NORMAL和ZONE_HIGHMEM。ZONE_HIGHMEM即为高端内存，这就是内存高端内存概念的由来。

在x86结构中，三种类型的区域如下：

**ZONE_DMA**        内存开始的16MB

**ZONE_NORMAL**       16MB~896MB

**ZONE_HIGHMEM**       896MB ~ 结束

![img](/Users/sinnera/sinnera.github.io/source/illustrations/linux_memory_05.png)

#### 理解

那么如内核是**如何借助128MB高端内存地址空间是如何实现访问可以所有物理内存**？

当内核想访问高于896MB物理地址内存时，从0xF8000000 ~ 0xFFFFFFFF地址空间范围内找一段相应大小空闲的逻辑地址空间，借用一会。借用这段逻辑地址空间，建立映射到想访问的那段物理内存（即填充内核PTE页面表），**临时用一会，用完后归还**。这样别人也可以借用这段地址空间访问其他物理内存，实现了使用有限的地址空间，访问所有所有物理内存。如下图。

![img](/Users/sinnera/sinnera.github.io/source/illustrations/linux_memory_06.png)

#### 划分

![img](/Users/sinnera/sinnera.github.io/source/illustrations/linux_memory_07.jpeg)

从图中可以看出，内核采用了三种机制将高端内存映射到内核空间：永久内核映射，固定映射和vmalloc机制。

#### 常见问题

1、用户空间（进程）是否有高端内存概念？

用户进程没有高端内存概念。只有在内核空间才存在高端内存。用户进程最多只可以访问3G物理内存，而内核进程可以访问所有物理内存。

2、64位内核中有高端内存吗？

目前现实中，64位Linux内核不存在高端内存，因为64位内核可以支持超过512GB内存。若机器安装的物理内存超过内核地址空间范围，就会存在高端内存。

3、用户进程能访问多少物理内存？内核代码能访问多少物理内存？

32位系统用户进程最大可以访问3GB，内核代码可以访问所有物理内存。

64位系统用户进程最大可以访问超过512GB，内核代码可以访问所有物理内存。

4、高端内存和物理地址、逻辑地址、线性地址的关系？

高端内存只和**物理地址**有关系，和线性地址、逻辑地址没有直接关系。

5、为什么不把所有的地址空间都分配给内核？

若把所有地址空间都给内存，那么用户进程怎么使用内存？怎么保证内核使用内存和用户进程不起冲突？

### 管理机制

基于物理内存在内核空间中的映射原理，物理内存的管理方式也有所不同。内核中物理内存的管理机制主要有伙伴算法，slab高速缓存和vmalloc机制。

其中伙伴算法和slab高速缓存都在**物理内存映射区**分配物理内存，而vmalloc机制则在**高端内存映射区**分配物理内存。

**伙伴算法**

伙伴算法负责**大块连续物理内存**的分配和释放，以页框为基本单位。该机制可以避免外部碎片。

**per-CPU页框高速缓存**

内核经常请求和释放单个页框，该缓存包含预先分配的页框，用于满足本地CPU发出的单一页框请求。

**slab缓存**

slab缓存负责**小块物理内存**的分配，并且它也作为高速缓存，主要针对内核中经常分配并释放的对象。

**vmalloc机制**

vmalloc机制使得内核通过连续的线性地址来访问非连续的物理页框，这样可以最大限度的使用高端物理内存。

### 内存分配

内核发出内存申请的请求时，根据内核函数调用接口将启用不同的内存分配器。

#### 分区页框分配器

分区页框分配器 (zoned page frame allocator) ,处理对**连续页框的内存分配请求**。分区页框管理器分为两大部分:前端的管理区分配器和伙伴系统，如下图：

![img](/Users/sinnera/sinnera.github.io/source/illustrations/linux_memory_08.jpeg)

管理区分配器负责搜索一个能满足请求页框块大小的管理区。在每个管理区中,具体的页框分配工作由伙伴系统负责。为了达到更好的系统性能,单个页框的申请工作直接通过per-CPU页框高速缓存完成。

#### slab分配器

slab 分配器最初是为了**解决物理内存的内部碎片**而提出的，它将内核中常用的数据结构看做对象。slab分配器为每一种对象建立高速缓存。内核对该对象的分配和释放均是在这块高速缓存中操作。一种对象的slab分配器结构图如下：

![img](/Users/sinnera/sinnera.github.io/source/illustrations/slab_cache.jpeg)

可以看到每种对象的高速缓存是由若干个slab组成，每个slab是由若干个页框组成的。虽然slab分配器可以分配比单个页框更小的内存块，但它所需的所有内存都是通过伙伴算法分配的。

slab高速缓存分专用缓存和通用缓存。专用缓存是对特定的对象，比如为内存描述符创建高速缓存。通用缓存则是针对一般情况，适合分配任意大小的物理内存，其接口即为kmalloc()。

#### 非连续内存区内存的分配

内核通过vmalloc()来**申请非连续的物理内存**，若申请成功，该函数返回连续内存区的起始地址，否则，返回NULL。vmalloc()和kmalloc()申请的内存有所不同，kmalloc()所申请内存的线性地址与物理地址都是连续的，而vmalloc()所申请的内存线性地址连续而物理地址则是离散的，两个地址之间通过内核页表进行映射。

vmalloc()的工作方式理解起来很简单：

1.寻找一个新的连续线性地址空间；

2.依次分配一组非连续的页框；

3.为线性地址空间和非连续页框建立映射关系，即修改内核页表；

vmalloc()的内存分配原理与用户态的内存分配相似，都是通过连续的虚拟内存来访问离散的物理内存，并且虚拟地址和物理地址之间是通过页表进行连接的，通过这种方式可以有效的使用物理内存。

注意：**vmalloc()申请物理内存时是立即分配的，因为内核认为这种内存分配请求是正当而且紧急的**；相反，用户态有内存请求时，内核总是尽可能的延后，毕竟用户态跟内核态不在一个特权级。

## 用户空间

### 段页式

**x86 CPU**采用了段页式地址映射模型。**进程代码**中的地址为逻辑地址，经过段页式地址映射后，才真正访问物理内存。

段页式机制如下图。

![img](http://ilinuxkernel.com/wp-content/uploads/2011/09/091011_1614_Linux1.png)

### 进程栈

Linux使用虚拟地址空间（task_struct->mm），大大增加了进程的寻址空间，由低地址到高地址分别为：

1. 只读段：该部分空间只能读，不可写，包括代码段、 rodata 段（ C 常量字符串和 #define 定义的常量）
2. 数据段：保存全局变量、静态变量的空间
3. 堆 ：就是平时所说的动态内存， malloc/new 大部分都来源于此。其中堆顶的位置可通过函数 brk 和 sbrk 进行动态调整。
4. 文件映射区域 ：如动态库、共享内存等映射物理空间的内存，一般是 mmap 函数所分配的虚拟地址空间。
5. 栈：用于维护函数调用的上下文空间，一般为 8M ，可通过 ulimit –s 查看。
6. 内核虚拟空间：用户代码不可见的内存区域，由内核管理。

另外， %esp 执行栈顶，往低地址方向变化； brk/sbrk 函数控制堆顶往高地址方向变化。

下图是 32 位系统典型的虚拟地址空间分布（来自《深入理解计算机系统》）

![img](/Users/sinnera/sinnera.github.io/source/illustrations/linux_memory_09.png)

### malloc的实现

malloc是glibc中内存分配函数，也是最常用的动态内存分配函数，其内存必须通过 free 进行释放，否则导致内存泄露。

关于 malloc 获得虚存空间的实现，与 glibc 的版本有关，但大体逻辑是：

1. 若分配内存小于 128k ，调用 sbrk() ，将堆顶指针向高地址移动，获得新的虚存空间。
2. 若分配内存大于 128k ，调用 mmap() ，在文件映射区域中分配匿名虚存空间。
3. 这里讨论的是简单情况，如果涉及并发可能会复杂一些，不过先不讨论。

其中 sbrk 就是修改栈顶指针位置，而 mmap 可用于生成文件的映射以及匿名页面的内存，这里指的是匿名页面。而这个 128k ，是 glibc 的默认配置，可通过函数 mallopt 来设置

不是 malloc 后就马上占用实际内存，而是第一次使用时发现虚存对应的物理页面未分配，产生缺页中断，才真正分配物理页面，同时更新进程页面的映射关系。这也是 Linux 虚拟内存管理的核心概念之一。

## 参考

[Linux与JVM的内存关系分析](https://tech.meituan.com/linux-jvm-memory.html)

[Linux内核高端内存](http://ilinuxkernel.com/?p=1013)

[十问 Linux 虚拟内存管理 (glibc) (一)](https://zhuanlan.zhihu.com/p/26137521)