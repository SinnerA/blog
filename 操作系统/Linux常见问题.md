---
title: Linux常见问题
date: 2018-08-30
tags: 
    - linux
---

[TOC]

## 基本概念

### 内核态和用户态

在CPU的所有指令中，有一些指令是非常危险的，如果错用，将导致整个系统崩溃。因此，划分为内核态（特权态）和用户态，用户态只能执行普通程序指令，比如库函数等，如果要执行一些特权指令，比如系统调用。

> 系统调用和普通库函数是相似的，只是系统调用由操作系统核心，可以理解为操作系统本身提供的系统功能，包括常见的IO操作函数：write/read，或者获取系统状态的函数，比如getpid

用户态如何切换到内核态：

- 系统调用：Linux会通过软中断执行系统调用，然后再返回
- 硬中断：外围设备完成操作，会向CPU发出中断信号
- 异常：典型的比如缺页中断

其实，都需要通过中断切换到内核态，无非是主动还是被动

系统调用与普通函数的区别：

1. 开销不同：系统调用开销大，需要中断，还有一些额外检查（权限等），普通函数直接调用即可
2. 运行空间不同：用户栈和内核栈
3. 返回问题：系统调用返回后需要重新调度

### 进程

进程是程序的一次执行过程，进程由PCB来描述，在Linux中就是task_struct。

PCB应该包含：

1. 进程标识符
2. 进程控制信息（状态，优先级，调度算法等）
3. 进程资源信息（进程栈，文件资源）
4. 上下文信息（通用寄存器，PC，PSW，用户栈指针）

**生命周期**：

通过fork来创建新进程，采用COW技术，只复制了页表，没有复制物理页面，运行时发生写操作再复制。IO中也使用了COW，先写入page cache，定期write-back或关闭文件时才写入磁盘。

exec执行进程，中途会经历就绪，运行，阻塞，终止等状态。

退出进程时，首先需要释放资源：地址空间，共享内存，打开文件等等；其次通知线程退出，并将子进程寻找新父进程；最后进行调度，切换到新进程。

**进程切换**：

切换进程需要通过软中断陷入到内核态，需要执行的步骤：

1. 切换页表以使用新的地址空间，页缓存失效
2. 保存CPU上下文到PCB，切换PCB

进程切换带来的消耗除了页表切换和上下文切换，还有cpu多核cache之间的共享数据失效。

**调度**：

1. 主动让出：sleep、exit、IO等
2. 时间片用完，CPU正常调度下一个任务
3. 被其他优先级更高的任务抢占
4. IO阻塞，调度器挂起当前任务，切换执行下一个任务
5. 中断，异常等

### 线程

引入进程是为了执行多道程序，能够并发执行。引入线程是为了**减少并发时带来的开销，进一步提高并发性能**。

与进程不同，进程包含了程序所需的所有资源，线程只包含了运行时的资源，比如栈、寄存器、程序计数器等

生命周期：

通过clone来创建新线程，实际上就是创建一个进程，与fork不同的是，不再复制父进程的栈空间，而是自己**创建一个新的，在进程的堆上分配的。**共享父进程的虚拟空间，自己又有独立栈。

pthread_create执行线程，中途会经历就绪，运行，阻塞，终止等状态。

线程结束有两种途径，函数执行结束，或者通过pthread_exit主动结束。由于进程（主线程）结束，会导致所有子线程结束，因此可以通过pthread_join来等待其他线程退出。

线程切换同样也需要陷入到内核态，执行步骤：

1. 保存CPU上下文到PCB，切换PCB

#### 进程与线程的区别

- 资源：
  - 独有：栈；上下文信息：寄存器，比如程序计数器（PC寄存器）；控制信息：线程id，状态等
  - 共享：堆，地址空间（也就是虚拟空间，或者说共享页表），文件资源，信号量等
- 上下文切换：
  - 进程：陷入内核态；切换页表，页缓存失效；保存上下文切换PCB
  - 线程：陷入内核态；保存上下文切换PCB
- 创建：创建线程比创建进程更加低消耗，因为创建线程不需要复制资源，只需要在进程的堆上创建自己的栈。
- 通信：
  - 进程：IPC：共享内存（涉及到系统调用）、消息、管道、信号、信号量等
  - 线程：可以直接读写进程数据段（如全局变量）来进行通信——需要进程**同步和互斥**手段的辅助，以保证数据的一致性。

#### 线程映射

有三种：1:1，n:1，m:n（用户线程数量 ：内核调度实体），很多地方表述的是用户线程与内核线程的映射关系，感觉不太好理解，应该理解为用户线程与调度实体的映射关系。

1:1：

- 每一个线程都能参与内核的调度，Linux的实现是1:1

- 每个线程都会经历用户态和内核态的切换

n:1：

- n个线程只能有一个参与调度

- 用户态决定哪个线程参与调度，因此只会存在一个调度实体，避免了切换开销，但是如果阻塞，将导致所有的线程都阻塞，因为只有一个调度实体

m:n：

- m个线程只能有n个参与调度，这里m>n
- 综合上面两者的优缺点：既能减少切换开销，也不会阻塞其他线程

#### 线程与进程的选择

多线程：

- 优势
  - 共享进程内数据
  - 上下文切换开销小
  - 同进程内通信开销小
  - 提高并发：进程内也能并发了
- 缺点：
  - 一个线程挂了，进程也挂了
  - 复杂性提高，同步、竞争和通信等

多进程：

- 优势：
  - 一个进程crash不会导致整个系统崩溃
  - 相互隔离，更加安全，进程内不需要竞争资源（...）
- 缺点：
  - 创建进程，进程切换、进程间通信开销大
  - 占用资源多

使用场景：

- 多进程：其他进程不能影响当前进程
- 多线程：需要大量共享数据或者频繁通信；需要大量并发，充分利用多核

**在能使用多进程解决一个问题的时候不要使用多线程。**

举例：

- 多进程

- - chrome是典型的多进程，一个页面挂掉，其他页面不受到影响。

  - Nginx也是多进程，Nginx是Master-worker模型，Master进程只负责管理Worker进程，而Worker进程是负责处理真实的请求。进程数不宜过多，不然带来更大的切换开销，

- 多线程

  - IM是典型的多线程，来了一个连接，新起线程去处理，如果是多进程，大量连接数会占用太多内存资源。

### 协程

线程是为了减少进程的并发开销，提高并发性能。协程的出现也是进一步减少并发开销，提高并发性能。

协程就是“协作的例程”，例程（过程、函数、方法、子程序）被定义为操作的序列，形成父子关系，子退出父才能退出，上下级关系。在协程中例程是平级关系，协作式的，而不是上下级调用。协程提供了一种机制，可以在例程的任意地方暂停，回来的时候继续从上次暂停的地方继续执行。

要实现协程，必要要有自己的栈用于保存上下文，还要提供调度协程的能力。

goroutine是协程的实现，G代表协程，G中包含栈信息，运行时函数信息，以及其他控制信息，如协程id，状态等

**好处：**

- 最大的好处：让原来要使用异步 + 回调方式写的非人类代码，可以用同步的方式写出来，其实底层还是异步的

  > 一般来说coroutine用在异步的场景比较好，异步执行一般需要维护一个状态机，状态的维护需要保存在全局里或者你传进来的参数来，因为每一个状态回调都会重新被调用。有了coroutine(stackfull)的话你可以不用担心这个问题，你可以像写同步的代码那样子，但其实底层还是异步的，只不过你在等待数据时执行的上下文会暂时被保存起来，等到数据来临再将上下文恢复继续执行。

- 避免了线程切换开销，从而避免陷入到内核态，上下文切换等开销
- 降低了内存消耗
- 提高了cpu缓存的利用率
- 充分利用多核优势，提高了并发

**缺点：**

协程不是银弹，减少了并发开销，提高了并发度，但是还是无法解决一些问题：

- 锁：协程也需要加锁
- IO：协程无法解决IO瓶颈

**调度：**

1. 被挂起：系统调用，go里面读写channel等
2. 抢占式调度

### 并发问题

并发主要带来了同步和互斥的问题

1. 同步：阻塞和唤醒，在go中可以使用channel或者waitGroup进行同步
2. 互斥：锁，锁的实现方式：硬件CAS、信号量、互斥量（01的信号量）

**死锁：**

并发时，资源的竞争导致的互相等待，无法向前推进，称为死锁。

产生原因：

1. 请求资源顺序不对，互相持有对方想要的资源
2. 信号量使用不对，比如互相等待对方发生信号给自己

产生的必要条件：互斥、不可剥夺、请求和保持、循环等待

想要避免死锁，只需打破四个必要条件即可，比如一次请求到位，或者按照约定顺序请求。

预防死锁，银行家算法：是否有足够资源，有则尝试分配资源并检查是否安全，不安全则拒绝分配

**go的死锁：**

channel 上如果发生了`流入和流出不配对`，就可能发生死锁。

解决办法：

1. 明确保证流入和流出成对出现
2. 当无法保证流入和流出成对出现时（例如无法预料多少流入），在流入完成后，关闭channel。因为如果采用range读取channel，channel不关闭，range一直在读取，所以写入之后就应该close
3. 利用缓冲。明确保证流入成对出现的话，可以使用缓冲来解决`流入`的阻塞。

### Linux命令 

CPU：

1. uptime：系统平均负载情况
2. ps/pstree：查看进程情况
3. top：所有进程的情况：CPU和内存的使用，优先级
4. mpstat：多CPU负载情况

内存：

1. free：内存使用情况：used,free,cached,swap
2. pmap：进程当前的内存使用情况

IO：

1. iostat：cpu负载和磁盘活动
2. vmstat：进程、内存、IO/swap、CPU

网络：

1. netstat：socket信息，包括状态，地址等
2. iptraf：网络实时流量
3. tcpdump：抓包

其他：

1. sar：实时收集数据，CPU、网络等
2. strace：拦截进程的系统调用和信号

## 常见问题

**为什么要区分堆栈**

因为需要存储的数据**生命周期不一样**，局部变量会在作用域结束后释放内存，函数调用也是FIFO，因此使用栈非常合适，也非常简单，压栈出栈即可。

函数结束后想要继续存在的数据，则需要分配在堆上，需要手动来分配和释放内存，分配和释放的次序也没有限制。

**goroutine使用时机**

1. 并发需求：服务器接受请求，每个请求分别用一个goroutine去处理，类似于master-worker模型
2. 性能优化：比如给一批用户发送消息，用户数很多，可以分批，分别开一个goroutine去执行
3. 后台执行：后台执行一些任务

**goroutine可以无限开吗**

goroutine开多了，主要有两个影响：

- 内存消耗
- 垃圾回收的速度变慢

一般的，64位机器下，开1M的协程没问题。1.4之前，栈默认8KB，之后是2KB，注意是连续栈，所以1M个协程占用空间大概2G。

## 参考

[内核态与用户态](https://segmentfault.com/a/1190000011899638)

[go - 关于使用 channel 时遇到的死锁问题](https://blog.csdn.net/hotdust/article/details/78283039)